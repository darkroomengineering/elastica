import t,{useEffect as e,useState as i,useRef as n,useCallback as s,useContext as r,createContext as o}from"react";function _extends(){return _extends=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var n in i)({}).hasOwnProperty.call(i,n)&&(t[n]=i[n])}return t},_extends.apply(null,arguments)}var a="undefined"!=typeof window&&new class{constructor(){this.raf=t=>{requestAnimationFrame(this.raf);const e=t-this.now;this.now=t;for(let i=0;i<this.callbacks.length;i++)this.callbacks[i].callback(t,e)},this.callbacks=[],this.now=performance.now(),requestAnimationFrame(this.raf)}add(t,e=0){return this.callbacks.push({callback:t,priority:e}),this.callbacks.sort(((t,e)=>t.priority-e.priority)),()=>this.remove(t)}remove(t){this.callbacks=this.callbacks.filter((({callback:e})=>t!==e))}},c=function debounce(t,e,i){var n=null,s=null,clear=function(){n&&(clearTimeout(n),s=null,n=null)},debounceWrapper=function(){if(!e)return t.apply(this,arguments);var r=this,o=arguments,a=i&&!n;return clear(),s=function(){t.apply(r,o)},n=setTimeout((function(){if(n=null,!a){var t=s;return s=null,t()}}),e),a?s():void 0};return debounceWrapper.cancel=clear,debounceWrapper.flush=function(){var t=s;clear(),t&&t()},debounceWrapper};function p(){return p=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n])}return t},p.apply(this,arguments)}function w(t){"sticky"===getComputedStyle(t).position&&(t.style.setProperty("position","relative"),t.dataset.sticky="true"),t.offsetParent&&w(t.offsetParent)}function b(t){var e;"true"===(null==t||null==(e=t.dataset)?void 0:e.sticky)&&(t.style.removeProperty("position"),delete t.dataset.sticky),t.parentNode&&b(t.parentNode)}function y(t,e=0){const i=e+t.offsetTop;return t.offsetParent?y(t.offsetParent,i):i}function z(t,e=0){const i=e+t.offsetLeft;return t.offsetParent?z(t.offsetParent,i):i}function E(t,e=0){var i;const n=e+(null!=(i=null==t?void 0:t.scrollTop)?i:0);return t.parentNode?E(t.parentNode,n):n+window.scrollY}function L(t,e=0){var i;const n=e+(null!=(i=null==t?void 0:t.scrollLeft)?i:0);return t.parentNode?L(t.parentNode,n):n+window.scrollX}const h={emit(t,...e){for(let i=0,n=this.events[t]||[],s=n.length;i<s;i++)n[i](...e)},events:{},on(t,e){return(this.events[t]||=[]).push(e),()=>{this.events[t]=this.events[t]?.filter((t=>e!==t))}}};function k({ignoreTransform:t=!1,ignoreSticky:r=!0,debounce:o=500,lazy:a=!1,callback:l}={}){const[u,d]=i(),m=n({}),[g,v]=i({}),x=s((({top:t,left:e,width:i,height:n,element:s})=>{var r,o,c,h,u;t=null!=(r=t)?r:m.current.top,e=null!=(o=e)?o:m.current.left,i=null!=(c=i)?c:m.current.width,n=null!=(h=n)?h:m.current.height,s=null!=(u=s)?u:m.current.element,t===m.current.top&&e===m.current.left&&i===m.current.width&&n===m.current.height&&s===m.current.element||(m.current.top=t,m.current.y=t,m.current.width=i,m.current.height=n,m.current.left=e,m.current.x=e,m.current.bottom=t+n,m.current.right=e+i,m.current.element=s,null==l||l(m.current),a||v(p({},m.current)))}),[a]);e((()=>{if(!u)return;const t=u.getBoundingClientRect();x({width:t.width,height:t.height});const e=c((([t])=>{x({width:t.borderBoxSize[0].inlineSize,height:t.borderBoxSize[0].blockSize})}),o),i=new ResizeObserver(e);return i.observe(u),()=>{i.disconnect(),e.cancel()}}),[u,o,x]);const[B,S]=i(),M=s((()=>{if(!u)return;let e,i;if(r&&w(u),t)e=y(u),i=z(u);else{const t=u.getBoundingClientRect();e=t.top+E(u),i=t.left+L(u)}r&&b(u),x({top:e,left:i,element:u})}),[t,r,u,x]);e((()=>{M();const t=c(M,o),e=new ResizeObserver(t);return e.observe(null!=B?B:document.body),()=>{e.disconnect(),t.cancel()}}),[B,o,M]);const O=s((()=>{if(!u)return;const t=u.getBoundingClientRect();x({width:t.width,height:t.height}),M()}),[u,M,x]);e((()=>(m.current.resize=O,a||v(p({},m.current)),h.on("resize",O))),[O,a]);const A=s((()=>m.current),[]);return[d,a?A:g,S]}k.resize=()=>{h.emit("resize")};class Elastica{constructor({gridSize:t=4,containerOffsets:e={top:0,bottom:0,left:0,right:0},collisions:i=!0,borders:n="rigid"}={}){this.calculatecCollisions=i,this.calculateBorders=n,this.gridSize=t,this.containerOffsets=e,this.positions=[],this.velocities=[],this.externalForces=[],this.dimensions=[],this.bounced=[],this.hash=[],this.container={},this.collisionsList=[]}initialCondition(t,e,i=()=>{}){this.container=e,this.dimensions=t.map(((t,e)=>{if(!t)return[0,0];this.externalForces[e]=[0,0],this.bounced[e]=0;const{rect:i}=t;return[i.width/2,i.height/2]})),i(this),this.positions.forEach(((e,i)=>{this.hash[i]=Math.floor(this.gridSize*(e[0]/this.container.width))+Math.floor(this.gridSize*(e[1]/this.container.height))*this.gridSize,this.setPosition(t[i]?.element,{x:e[0]-this.dimensions[i][0],y:e[1]-this.dimensions[i][1]})}))}polarCoordinates(t){return{speed:Math.sqrt(t[0]*t[0]+t[1]*t[1]),angle:Math.atan2(t[1],t[0])}}cartesianCoordinates(t,e){return[t*Math.cos(e),t*Math.sin(e)]}hasBounced(t){return this.bounced[t]+=1}setPosition(t,{x:e=0,y:i=0,z:n=0}){t&&(t.style.cssText=`transform: translate3d(${e}px, ${i}px, ${n}px); will-change: transform;`)}rigidBorders(t){if("rigid"!==this.calculateBorders)return;const e=this.containerOffsets.top,i=this.containerOffsets.left,n=this.containerOffsets.right+1,s=this.containerOffsets.bottom+1;for(let r=0;r<t.length;r++){const t=this.dimensions[r];let o=this.velocities[r],a=this.positions[r];a[1]<t[1]+this.container.height*e&&(this.hasBounced(r),this.velocities[r][1]=-o[1],this.positions[r][1]=t[1]+this.container.height*e),a[0]<t[0]+this.container.width*i&&(this.hasBounced(r),this.velocities[r][0]=-o[0],this.positions[r][0]=t[0]+this.container.width*i),a[1]>this.container.height*s-t[1]&&(this.hasBounced(r),this.velocities[r][1]=-o[1],this.positions[r][1]=this.container.height*s-t[1]),a[0]>this.container.width*n-t[0]&&(this.hasBounced(r),this.velocities[r][0]=-o[0],this.positions[r][0]=this.container.width*n-t[0])}}periodicBorders(t){if("periodic"!==this.calculateBorders)return;const e=this.containerOffsets.top,i=this.containerOffsets.left,n=this.containerOffsets.right+1,s=this.containerOffsets.bottom+1;for(let r=0;r<t.length;r++){const t=this.dimensions[r];let o=this.positions[r],a=this.velocities[r].map((t=>Math.sign(t)));-1===a[1]&&o[1]<t[1]+this.container.height*e&&(this.positions[r][1]=t[1]+this.container.height*s),1===a[1]&&o[1]>this.container.height*s-t[1]&&(this.positions[r][1]=this.container.height*e-t[1]),-1===a[0]&&o[0]<t[0]+this.container.width*i&&(this.positions[r][0]=t[0]+this.container.width*n),1===a[0]&&o[0]>this.container.width*n-t[0]&&(this.positions[r][0]=this.container.width*i-t[0])}}isNeighboor(t,e){const i=this.hash[e];let n=this.hash[t],s=!1;for(let t=-1;t<2;t++)for(let e=-1;e<2;e++){let r=n+this.gridSize*t+e;if(!(r<0||r>this.gridSize*this.gridSize)&&r===i){s=!0;break}}return s}axisAlignedBoundaryBoxes(t,e){const i=this.dimensions[t],n=this.positions[t],s=this.dimensions[e],r=this.positions[e];return n.map(((t,e)=>Math.abs(t-r[e])<i[e]+s[e])).every((t=>t))}calculateSuperposition(t,e){const i=this.positions[t],n=this.dimensions[t],s=this.positions[e],r=this.dimensions[e],o=i.map(((t,e)=>n[e]+r[e]-Math.abs(t-s[e]))),a=i.map(((t,e)=>-Math.sign(t-s[e])));return o.map(((t,e)=>a[e]*Math.max(1/t,.5)))}collisions(t){if(this.calculatecCollisions){this.collisionsList=[];for(let e=0;e<t.length;e++){let t=this.velocities[e];this.hash.forEach(((i,n)=>{if(n===e)return;let s=this.velocities[n];if(this.collisionsList.some((({loop:t,inHash:i})=>t===n&&i===e)))return;if(!this.isNeighboor(e,n))return;if(!this.axisAlignedBoundaryBoxes(e,n))return;this.collisionsList.push({loop:e,inHash:n});const r=.5*(t.reduce(((t,e)=>t+e*e),0)+s.reduce(((t,e)=>t+e*e),0));let o=this.calculateSuperposition(e,n),a=t.map(((t,e)=>t+o[e])),c=s.map(((t,e)=>t-o[e]));const h=.5*(a.reduce(((t,e)=>t+e*e),0)+c.reduce(((t,e)=>t+e*e),0));if(0!==h){const t=Math.sqrt(r/h);a=a.map((e=>e*t)),c=c.map((e=>e*t))}this.velocities[e]=c,this.velocities[n]=a}))}}}update(t,e){this.rigidBorders(t),this.periodicBorders(t),this.collisions(t),e(this),this.positions.forEach(((t,e)=>{this.hash[e]=Math.floor(this.gridSize*t[0]/this.container.width)+Math.floor(this.gridSize*t[1]/this.container.height)*this.gridSize}))}}const l={random:function randominitialCondition({boxes:t,positions:e,velocities:i,container:n}){t.forEach(((t,s)=>{e[s]=[Math.random()*n.width,Math.random()*n.height],i[s]=[.5*(Math.random()-.5),.5*(Math.random()-.5)]}))}};const u={dvdScreenSaver:function dvdScreenSaver({boxes:t,positions:e,velocities:i,deltaTime:n}){t.forEach(((t,s)=>{e[s]=e[s].map(((t,e)=>t+i[s][e]*n))}))},DragAndGravity:function DragAndGravity({boxes:t,positions:e,velocities:i,deltaTime:n,externalForces:s}){t.forEach(((t,r)=>{let o=i[r],a=e[r],c=s[r];const h=[0,-.1];o=o.map(((t,e)=>t+-.001*n*(t-4*c[e]+h[e]))),a=a.map(((t,e)=>t+o[e]*n)),e[r]=a,i[r]=o,s[r]=[0,0]}))},rightFlow:function rightFlow({boxes:t,positions:e,velocities:i,externalForces:n,deltaTime:s}){t.forEach(((t,r)=>{let o=i[r],a=e[r],c=n[r];const h=[.5*(Math.random()-.5),.05*(Math.random()-.5)];o=o.map(((t,e)=>t+-.001*s*(t-4*c[e]+h[e]))),e[r]=a=a.map(((t,e)=>t+o[e]*s)),e[r]=a,i[r]=o,n[r]=[0,0]}))}};const d={default:function dragForce(t,e,i){let n=t.map((t=>t*t)).reduce(((t,e)=>t+e));n=Math.sqrt(n),0!==n&&(e[i]=t.map((t=>t/n)))}};const m={display:"flex",justifyContent:"space-between",position:"fixed",inset:0,pointerEvents:"none",width:"100%",height:"100%"};function HashGrid({gridSize:e}){return t.createElement(t.Fragment,null,t.createElement("div",{style:{...m}},new Array(e+1).fill(0).map(((e,i)=>t.createElement("span",{key:i,style:{border:"1px solid white"}})))),t.createElement("div",{style:{flexDirection:"column",...m}},new Array(e+1).fill(0).map(((e,i)=>t.createElement("span",{key:i,style:{border:"1px solid white"}})))))}const g=o({});function useElastica(){return r(g)}function ReactElastica({children:r,className:o,config:c={gridSize:8,collisions:!0,borders:"rigid",containerOffsets:{top:0,bottom:0,left:0,right:0}},initialCondition:h=()=>{},update:l=()=>{},showHashGrid:u=!1}){const d=n(0),m=n(new Map),[v,x]=k(),[B,S]=function useJavascriptEnable(t=!0){const[n,s]=i(t);return e((()=>(document.addEventListener("visibilitychange",(()=>{"hidden"===document.visibilityState&&s(!1)})),()=>{document.removeEventListener("visibilitychange",(()=>{}))})),[]),[n,s]}(),[M,O]=i((()=>new Elastica(c)));e((()=>{O(new Elastica(c))}),[c]);const A=s(((t,e)=>{m.current.set(t,e)}),[]),P=s((t=>{m.current.delete(t)}),[]);return e((()=>{const t=[...m.current.values()];(function isEmptyArray(t){return!t||Array.isArray(t)&&0===t.length})(t)||t.some((({rect:t})=>!t))||M.initialCondition(t,x,(e=>h({boxes:t,...e})))}),[M,x]),function f(t,i=0){e((()=>{if(t)return a.add(t,i),()=>a.remove(t)}),[t,i])}((t=>{const e=[...m.current.values()];B||(d.current=t,S(!0));const i=Math.min(t-d.current,100);d.current=t,M.update(e,(t=>{l({boxes:e,...t,deltaTime:i}),e.forEach(((e,i)=>{const n=t.positions[i],s=t.dimensions[i];t?.setPosition(e?.element,{x:n[0]-s[0],y:n[1]-s[1]})}))}))})),t.createElement("div",{className:o,ref:v,style:{position:"relative",width:"100%",height:"100%"}},t.createElement(g.Provider,{value:{addBox:A,removeBox:P,elastica:M}},r,u&&t.createElement(HashGrid,{gridSize:M.gridSize})))}function AxisAlignedBoundaryBox({className:i,children:s,...r}){const{addBox:o,removeBox:a,elastica:c}=useElastica(),[h,l]=k(),u=n();return e((()=>{if(u.current)return o(u.current,{element:u.current,rect:l}),()=>{a(u.current)}}),[l,o,a]),t.createElement("div",_extends({ref:t=>{u.current=t,h(t)},className:i},r),s)}export{AxisAlignedBoundaryBox,ReactElastica as default,d as dragForcePresetsLib,l as initalConditionsPresets,u as updatePresets,useElastica};
//# sourceMappingURL=elastica-react.mjs.map
