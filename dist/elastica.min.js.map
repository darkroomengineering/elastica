{"version":3,"file":"elastica.min.js","sources":["../packages/engine/src/index.js"],"sourcesContent":["export default class Elastica {\n  constructor({\n    gridSize = 4,\n    containerOffsets = { top: 0, bottom: 0, left: 0, right: 0 },\n    collisions = true,\n    borders = 'rigid',\n  } = {}) {\n    this.calculatecCollisions = collisions\n    this.calculateBorders = borders\n    this.gridSize = gridSize\n    this.containerOffsets = containerOffsets\n    this.positions = []\n    this.velocities = []\n    this.externalForces = []\n    this.dimensions = []\n    this.bounced = []\n    this.hash = []\n    this.container = {}\n    this.collisionsList = []\n  }\n  //TODO pass elements to objects and not to array\n\n  initialCondition(elements, rect, callback = () => {}) {\n    this.container = rect\n\n    this.dimensions = elements.map((element, index) => {\n      if (!element) return [0, 0]\n\n      this.externalForces[index] = [0, 0]\n      this.bounced[index] = 0\n\n      const { rect: elementRect } = element\n\n      return [elementRect.width / 2, elementRect.height / 2]\n    })\n\n    callback(this)\n\n    this.positions.forEach((pos, index) => {\n      this.hash[index] =\n        Math.floor(this.gridSize * (pos[0] / this.container.width)) +\n        Math.floor(this.gridSize * (pos[1] / this.container.height)) *\n          this.gridSize\n\n      this.setPosition(elements[index]?.element, {\n        x: pos[0] - this.dimensions[index][0],\n        y: pos[1] - this.dimensions[index][1],\n      })\n    })\n  }\n\n  polarCoordinates(vector) {\n    let speed = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1])\n    const angle = Math.atan2(vector[1], vector[0])\n\n    return { speed, angle }\n  }\n\n  cartesianCoordinates(speed, angle) {\n    return [speed * Math.cos(angle), speed * Math.sin(angle)]\n  }\n\n  hasBounced(index) {\n    return (this.bounced[index] += 1)\n  }\n\n  setPosition(element, { x = 0, y = 0, z = 0 }) {\n    if (element) {\n      element.style.cssText = `transform: translate3d(${x}px, ${y}px, ${z}px); will-change: transform;`\n    }\n  }\n\n  rigidBorders(elements) {\n    if (this.calculateBorders !== 'rigid') return\n\n    const top = this.containerOffsets.top\n    const left = this.containerOffsets.left\n    const right = this.containerOffsets.right + 1\n    const bottom = this.containerOffsets.bottom + 1\n\n    for (let index = 0; index < elements.length; index++) {\n      // Particle cinematic properties\n      const dimension = this.dimensions[index]\n      let velocity = this.velocities[index]\n      let position = this.positions[index]\n\n      // Top wall\n      if (position[1] < dimension[1] + this.container.height * top) {\n        this.hasBounced(index)\n        this.velocities[index][1] = -velocity[1]\n        this.positions[index][1] = dimension[1] + this.container.height * top\n      }\n\n      // Left wall\n      if (position[0] < dimension[0] + this.container.width * left) {\n        this.hasBounced(index)\n        this.velocities[index][0] = -velocity[0]\n        this.positions[index][0] = dimension[0] + this.container.width * left\n      }\n\n      // Bottom wall\n      if (position[1] > this.container.height * bottom - dimension[1]) {\n        this.hasBounced(index)\n        this.velocities[index][1] = -velocity[1]\n        this.positions[index][1] = this.container.height * bottom - dimension[1]\n      }\n\n      // Right wall\n      if (position[0] > this.container.width * right - dimension[0]) {\n        this.hasBounced(index)\n        this.velocities[index][0] = -velocity[0]\n        this.positions[index][0] = this.container.width * right - dimension[0]\n      }\n    }\n  }\n\n  periodicBorders(elements) {\n    if (this.calculateBorders !== 'periodic') return\n\n    const top = this.containerOffsets.top\n    const left = this.containerOffsets.left\n    const right = this.containerOffsets.right + 1\n    const bottom = this.containerOffsets.bottom + 1\n\n    for (let index = 0; index < elements.length; index++) {\n      // Particle cinematic properties\n      const dimension = this.dimensions[index]\n      let position = this.positions[index]\n      let dir = this.velocities[index].map((v) => Math.sign(v))\n\n      // Top wall\n      if (\n        dir[1] === -1 &&\n        position[1] < dimension[1] + this.container.height * top\n      ) {\n        this.positions[index][1] = dimension[1] + this.container.height * bottom\n      }\n\n      // Bottom wall\n      if (\n        dir[1] === 1 &&\n        position[1] > this.container.height * bottom - dimension[1]\n      ) {\n        this.positions[index][1] = this.container.height * top - dimension[1]\n      }\n\n      // Left wall\n      if (\n        dir[0] === -1 &&\n        position[0] < dimension[0] + this.container.width * left\n      ) {\n        this.positions[index][0] = dimension[0] + this.container.width * right\n      }\n\n      // Right wall\n      if (\n        dir[0] === 1 &&\n        position[0] > this.container.width * right - dimension[0]\n      ) {\n        this.positions[index][0] = this.container.width * left - dimension[0]\n      }\n    }\n  }\n\n  isNeighboor(current, index) {\n    const neighboorHash = this.hash[index]\n    let hashItem = this.hash[current]\n    let isNeighboor = false\n\n    for (let i = -1; i < 2; i++) {\n      for (let j = -1; j < 2; j++) {\n        let box = hashItem + this.gridSize * i + j\n\n        if (box < 0 || box > this.gridSize * this.gridSize) {\n          continue\n        }\n\n        if (box === neighboorHash) {\n          isNeighboor = true\n          break\n        }\n      }\n    }\n\n    return isNeighboor\n  }\n\n  axisAlignedBoundaryBoxes(index, idy) {\n    const dimension = this.dimensions[index]\n    const position = this.positions[index]\n\n    const neighboorDimension = this.dimensions[idy]\n    const neighboorPosition = this.positions[idy]\n\n    const overlaping = position.map(\n      (pos, idx) =>\n        Math.abs(pos - neighboorPosition[idx]) <\n        dimension[idx] + neighboorDimension[idx],\n    )\n\n    return overlaping.every((overlap) => overlap)\n  }\n\n  //TODO improve this function\n  calculateSuperposition(index, idy) {\n    const posA = this.positions[index]\n    const dimA = this.dimensions[index]\n    const posB = this.positions[idy]\n    const dimB = this.dimensions[idy]\n\n    const overlaping = posA.map(\n      (pos, idx) => dimA[idx] + dimB[idx] - Math.abs(pos - posB[idx]),\n    )\n\n    const overlapDir = posA.map((pos, idx) => -Math.sign(pos - posB[idx]))\n\n    return overlaping.map((v, i) => overlapDir[i] * Math.max(1 / v, 0.5))\n  }\n\n  collisions(elements) {\n    if (!this.calculatecCollisions) return\n    this.collisionsList = []\n\n    for (let index = 0; index < elements.length; index++) {\n      let velocity = this.velocities[index]\n\n      // Collisions from particle X to all other\n      this.hash.forEach((neighboorHash, idy) => {\n        //Discard same element\n        if (idy === index) return\n\n        let neighboorVelocity = this.velocities[idy]\n\n        // Collisions are pairwise so need to check if already collided\n        if (\n          this.collisionsList.some(\n            ({ loop, inHash }) => loop === idy && inHash === index,\n          )\n        )\n          return\n\n        // Discard if not a neighboor\n        if (!this.isNeighboor(index, idy)) return\n\n        const hasCollision = this.axisAlignedBoundaryBoxes(index, idy)\n\n        //no colisions\n        if (!hasCollision) {\n          return\n        }\n\n        // Add to collision list\n        this.collisionsList.push({ loop: index, inHash: idy })\n\n        // Calculate initial kinetic energy\n        const initialKE =\n          0.5 *\n          (velocity.reduce((sum, v) => sum + v * v, 0) +\n            neighboorVelocity.reduce((sum, v) => sum + v * v, 0))\n\n        // Resolve superpositions\n        let exclusionForce = this.calculateSuperposition(index, idy)\n\n        // Apply superposition forces\n        let collisonVelocity = velocity.map((v, idx) => v + exclusionForce[idx])\n        let neighboorCollisionVelocity = neighboorVelocity.map(\n          (v, idx) => v - exclusionForce[idx],\n        )\n\n        // Calculate new kinetic energy\n        const finalKE =\n          0.5 *\n          (collisonVelocity.reduce((sum, v) => sum + v * v, 0) +\n            neighboorCollisionVelocity.reduce((sum, v) => sum + v * v, 0))\n\n        // Scale velocities to conserve energy\n        if (finalKE !== 0) {\n          const scale = Math.sqrt(initialKE / finalKE)\n          collisonVelocity = collisonVelocity.map((v) => v * scale)\n          neighboorCollisionVelocity = neighboorCollisionVelocity.map(\n            (v) => v * scale,\n          )\n        }\n\n        // Swap velocities\n        this.velocities[index] = neighboorCollisionVelocity\n        this.velocities[idy] = collisonVelocity\n      })\n    }\n  }\n\n  update(elements, callback) {\n    this.rigidBorders(elements)\n    this.periodicBorders(elements)\n    this.collisions(elements)\n    callback(this)\n\n    this.positions.forEach((pos, index) => {\n      this.hash[index] =\n        Math.floor((this.gridSize * pos[0]) / this.container.width) +\n        Math.floor((this.gridSize * pos[1]) / this.container.height) *\n          this.gridSize\n    })\n  }\n}\n"],"names":["Elastica","constructor","gridSize","containerOffsets","top","bottom","left","right","collisions","borders","this","calculatecCollisions","calculateBorders","positions","velocities","externalForces","dimensions","bounced","hash","container","collisionsList","initialCondition","elements","rect","callback","map","element","index","elementRect","width","height","forEach","pos","Math","floor","setPosition","x","y","polarCoordinates","vector","speed","sqrt","angle","atan2","cartesianCoordinates","cos","sin","hasBounced","z","style","cssText","rigidBorders","length","dimension","velocity","position","periodicBorders","dir","v","sign","isNeighboor","current","neighboorHash","hashItem","i","j","box","axisAlignedBoundaryBoxes","idy","neighboorDimension","neighboorPosition","idx","abs","every","overlap","calculateSuperposition","posA","dimA","posB","dimB","overlaping","overlapDir","max","neighboorVelocity","some","loop","inHash","push","initialKE","reduce","sum","exclusionForce","collisonVelocity","neighboorCollisionVelocity","finalKE","scale","update"],"mappings":"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"}