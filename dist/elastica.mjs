class Elastica{constructor({gridSize:i=4,containerOffsets:t={top:0,bottom:0,left:0,right:0},collisions:s=!0,borders:e="rigid"}={}){this.calculatecCollisions=s,this.calculateBorders=e,this.gridSize=i,this.containerOffsets=t,this.positions=[],this.velocities=[],this.externalForces=[],this.dimensions=[],this.bounced=[],this.hash=[],this.container={},this.collisionsList=[]}initialCondition(i,t,s=()=>{}){this.container=t,this.dimensions=i.map(((i,t)=>{if(!i)return[0,0];this.externalForces[t]=[0,0],this.bounced[t]=0;const{rect:s}=i;return[s.width/2,s.height/2]})),s(this),this.positions.forEach(((t,s)=>{this.hash[s]=Math.floor(this.gridSize*(t[0]/this.container.width))+Math.floor(this.gridSize*(t[1]/this.container.height))*this.gridSize,this.setPosition(i[s]?.element,{x:t[0],y:t[1]})}))}polarCoordinates(i){return{speed:Math.sqrt(i[0]*i[0]+i[1]*i[1]),angle:Math.atan2(i[1],i[0])}}cartesianCoordinates(i,t){return[i*Math.cos(t),i*Math.sin(t)]}hasBounced(i){return this.bounced[i]+=1}setPosition(i,{x:t=0,y:s=0,z:e=0}){i&&(i.style.cssText=`transform: translate3d(${t}px, ${s}px, ${e}px);`)}rigidBorders(i){if("rigid"!==this.calculateBorders)return;const t=this.containerOffsets.top,s=this.containerOffsets.left,e=this.containerOffsets.right+1,o=this.containerOffsets.bottom+1;for(let h=0;h<i.length;h++){const i=this.dimensions[h];let n=this.velocities[h],r=this.positions[h];r[1]<i[1]+this.container.height*t&&(this.hasBounced(h),this.velocities[h][1]=-n[1],this.positions[h][1]=i[1]+this.container.height*t),r[0]<i[0]+this.container.width*s&&(this.hasBounced(h),this.velocities[h][0]=-n[0],this.positions[h][0]=i[0]+this.container.width*s),r[1]>this.container.height*o-i[1]&&(this.hasBounced(h),this.velocities[h][1]=-n[1],this.positions[h][1]=this.container.height*o-i[1]),r[0]>this.container.width*e-i[0]&&(this.hasBounced(h),this.velocities[h][0]=-n[0],this.positions[h][0]=this.container.width*e-i[0])}}periodicBorders(i){if("periodic"!==this.calculateBorders)return;const t=this.containerOffsets.top,s=this.containerOffsets.left,e=this.containerOffsets.right+1,o=this.containerOffsets.bottom+1;for(let h=0;h<i.length;h++){const i=this.dimensions[h];let n=this.positions[h],r=this.velocities[h].map((i=>Math.sign(i)));-1===r[1]&&n[1]<i[1]+this.container.height*t&&(this.positions[h][1]=i[1]+this.container.height*o),1===r[1]&&n[1]>this.container.height*o-i[1]&&(this.positions[h][1]=this.container.height*t-i[1]),-1===r[0]&&n[0]<i[0]+this.container.width*s&&(this.positions[h][0]=i[0]+this.container.width*e),1===r[0]&&n[0]>this.container.width*e-i[0]&&(this.positions[h][0]=this.container.width*s-i[0])}}isNeighboor(i,t){const s=this.hash[t];let e=this.hash[i],o=!1;for(let i=-1;i<2;i++)for(let t=-1;t<2;t++){let h=e+this.gridSize*i+t;if(!(h<0||h>this.gridSize*this.gridSize)&&h===s){o=!0;break}}return o}axisAlignedBoundaryBoxes(i,t){const s=this.dimensions[i],e=this.positions[i],o=this.dimensions[t],h=this.positions[t];return e.map(((i,t)=>Math.abs(i-h[t])<s[t]+o[t])).every((i=>i))}calculateSuperposition(i,t){const s=this.positions[i],e=this.dimensions[i],o=this.positions[t],h=this.dimensions[t],n=s.map(((i,t)=>e[t]+h[t]-Math.abs(i-o[t]))),r=s.map(((i,t)=>-Math.sign(i-o[t])));return n.map(((i,t)=>r[t]*Math.max(1/i,.1)))}collisions(i){if(this.calculatecCollisions){this.collisionsList=[];for(let t=0;t<i.length;t++){let i=this.velocities[t];this.hash.forEach(((s,e)=>{if(e===t)return;let o=this.velocities[e];if(this.collisionsList.some((({loop:i,inHash:s})=>i===e&&s===t)))return;if(!this.isNeighboor(t,e))return;if(!this.axisAlignedBoundaryBoxes(t,e))return;this.collisionsList.push({loop:t,inHash:e});const h=.5*(i.reduce(((i,t)=>i+t*t),0)+o.reduce(((i,t)=>i+t*t),0));let n=this.calculateSuperposition(t,e),r=i.map(((i,t)=>i+n[t])),a=o.map(((i,t)=>i-n[t]));const c=.5*(r.reduce(((i,t)=>i+t*t),0)+a.reduce(((i,t)=>i+t*t),0));if(0!==c){const i=Math.sqrt(h/c);r=r.map((t=>t*i)),a=a.map((t=>t*i))}this.velocities[t]=a,this.velocities[e]=r}))}}}update(i,t){this.rigidBorders(i),this.periodicBorders(i),this.collisions(i),t(this),this.positions.forEach(((i,t)=>{this.hash[t]=Math.floor(this.gridSize*i[0]/this.container.width)+Math.floor(this.gridSize*i[1]/this.container.height)*this.gridSize}))}}export{Elastica as default};
//# sourceMappingURL=elastica.mjs.map
