!function(i,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(i="undefined"!=typeof globalThis?globalThis:i||self)["Elastic Collisions"]=t()}(this,(function(){"use strict";return class ElasticCollision{constructor({gridSize:i=4,containerOffsets:t={top:0,bottom:0,left:0,right:0},collisions:s=!0,borders:e="rigid",collisionRandomness:o=0}={}){this.calculatecCollisions=s,this.calculateBorders=e,this.collisionRandomness=o,this.gridSize=i,this.containerOffsets=t,this.positions=[],this.velocities=[],this.externalForces=[],this.dimensions=[],this.bounced=[],this.hash=[],this.container={},this.collisionsList=[]}initialConditions(i,t,s=()=>{}){this.container=t,this.dimensions=i.map(((i,t)=>{if(!i)return[0,0];this.externalForces[t]=[0,0];const{rect:s}=i;return[s.width/2,s.height/2]})),s(this),this.positions.forEach(((t,s)=>{this.hash[s]=Math.floor(this.gridSize*(t[0]/this.container.width))+Math.floor(this.gridSize*(t[1]/this.container.height))*this.gridSize,this.setPosition(i[s]?.element,{x:t[0],y:t[1]})}))}polarCoordinates(i){return{speed:Math.sqrt(i[0]*i[0]+i[1]*i[1]),angle:Math.atan2(i[1],i[0])}}cartesianCoordinates(i,t){return[i*Math.cos(t),i*Math.sin(t)]}hasBounced(i){return this.bounced[i]+=1}setPosition(i,{x:t=0,y:s=0,z:e=0}){i&&(i.style.cssText=`transform: translate3d(${t}px, ${s}px, ${e}px);`)}rigidBorders(i){if("rigid"!==this.calculateBorders)return;const t=this.containerOffsets.top,s=this.containerOffsets.left,e=this.containerOffsets.right+1,o=this.containerOffsets.bottom+1;for(let n=0;n<i.length;n++){const i=this.dimensions[n];let h=this.velocities[n],r=this.positions[n];r[1]<i[1]+this.container.height*t&&(this.hasBounced(n),this.velocities[n][1]=-h[1],this.positions[n][1]=i[1]+this.container.height*t),r[0]<i[0]+this.container.width*s&&(this.hasBounced(n),this.velocities[n][0]=-h[0],this.positions[n][0]=i[0]+this.container.width*s),r[1]>this.container.height*o-i[1]&&(this.hasBounced(n),this.velocities[n][1]=-h[1],this.positions[n][1]=this.container.height*o-i[1]),r[0]>this.container.width*e-i[0]&&(this.hasBounced(n),this.velocities[n][0]=-h[0],this.positions[n][0]=this.container.width*e-i[0])}}periodicBorders(i){if("periodic"!==this.calculateBorders)return;const t=this.containerOffsets.top,s=this.containerOffsets.left,e=this.containerOffsets.right+1,o=this.containerOffsets.bottom+1;for(let n=0;n<i.length;n++){const i=this.dimensions[n];let h=this.positions[n],r=this.velocities[n].map((i=>Math.sign(i)));-1===r[1]&&h[1]<i[1]+this.container.height*t&&(this.positions[n][1]=i[1]+this.container.height*o),1===r[1]&&h[1]>this.container.height*o-i[1]&&(this.positions[n][1]=this.container.height*t-i[1]),-1===r[0]&&h[0]<i[0]+this.container.width*s&&(this.positions[n][0]=i[0]+this.container.width*e),1===r[0]&&h[0]>this.container.width*e-i[0]&&(this.positions[n][0]=this.container.width*s-i[0])}}isNeighboor(i,t){const s=this.hash[t];let e=this.hash[i],o=!1;for(let i=-1;i<2;i++)for(let t=-1;t<2;t++){let n=e+this.gridSize*i+t;if(!(n<0||n>this.gridSize*this.gridSize)&&n===s){o=!0;break}}return o}axisAlignedBoundaryBoxes(i,t){const s=this.dimensions[i],e=this.positions[i],o=this.dimensions[t],n=this.positions[t];return e.map(((i,t)=>Math.abs(i-n[t])<s[t]+o[t])).every((i=>i))}calculateSuperposition(i,t){let s=[0,0];const e=this.positions[i],o=this.dimensions[i],n=this.positions[t],h=this.dimensions[t],r=e.map(((i,t)=>o[t]+h[t]-Math.abs(i-n[t])));return r[0]<r[1]?e[0]<n[0]?s[0]=r[0]:s[0]=-r[0]:e[1]<n[1]?s[1]=r[1]:s[1]=-r[1],s.map((i=>i+Math.random()*this.collisionRandomness))}collisions(i){if(this.calculatecCollisions){this.collisionsList=[];for(let t=0;t<i.length;t++){let i=this.velocities[t];this.hash.forEach(((s,e)=>{if(e===t)return;let o=this.velocities[e];if(this.collisionsList.some((({loop:i,inHash:s})=>i===e&&s===t)))return;if(!this.isNeighboor(t,e))return;if(!this.axisAlignedBoundaryBoxes(t,e))return;this.collisionsList.push({loop:t,inHash:e});const n=.5*(i.reduce(((i,t)=>i+t*t),0)+o.reduce(((i,t)=>i+t*t),0)),h=this.calculateSuperposition(t,e);let r=i.map(((i,t)=>i+h[t])),a=o.map(((i,t)=>i-h[t]));const c=.5*(r.reduce(((i,t)=>i+t*t),0)+a.reduce(((i,t)=>i+t*t),0));if(0!==c){const i=Math.sqrt(n/c);r=r.map((t=>t*i)),a=a.map((t=>t*i))}this.velocities[t]=a,this.velocities[e]=r}))}}}update(i,t){this.rigidBorders(i),this.periodicBorders(i),this.collisions(i),t(this),this.positions.forEach(((i,t)=>{this.hash[t]=Math.floor(this.gridSize*i[0]/this.container.width)+Math.floor(this.gridSize*i[1]/this.container.height)*this.gridSize}))}}}));
//# sourceMappingURL=elastic-collisions.min.js.map
