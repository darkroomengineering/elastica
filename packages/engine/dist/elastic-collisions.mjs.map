{"version":3,"file":"elastic-collisions.mjs","sources":["../src/index.js"],"sourcesContent":["export default class ElasticCollision {\n  constructor({\n    gridSize = 4,\n    containerOffsets = { top: 0, bottom: 0, left: 0, right: 0 },\n    collisions = true,\n    borders = 'rigid',\n    collisionRandomness = 0,\n  } = {}) {\n    this.calculatecCollisions = collisions\n    this.calculateBorders = borders\n    this.collisionRandomness = collisionRandomness\n    this.gridSize = gridSize\n    this.containerOffsets = containerOffsets\n    this.positions = []\n    this.velocities = []\n    this.externalForces = []\n    this.dimensions = []\n    this.bounced = []\n    this.hash = []\n    this.container = {}\n    this.collisionsList = []\n  }\n  //todo pass elements to objects and not to array\n\n  initialConditions(elements, rect, callback = () => {}) {\n    this.container = rect\n\n    this.dimensions = elements.map((element, index) => {\n      if (!element) return [0, 0]\n\n      this.externalForces[index] = [0, 0]\n\n      const { rect: elementRect } = element\n\n      return [elementRect.width / 2, elementRect.height / 2]\n    })\n\n    callback(this)\n\n    this.positions.forEach((pos, index) => {\n      this.hash[index] =\n        Math.floor(this.gridSize * (pos[0] / this.container.width)) +\n        Math.floor(this.gridSize * (pos[1] / this.container.height)) *\n          this.gridSize\n\n      this.setPosition(elements[index]?.element, {\n        x: pos[0],\n        y: pos[1],\n      })\n    })\n  }\n\n  polarCoordinates(vector) {\n    let speed = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1])\n    const angle = Math.atan2(vector[1], vector[0])\n\n    return { speed, angle }\n  }\n\n  cartesianCoordinates(speed, angle) {\n    return [speed * Math.cos(angle), speed * Math.sin(angle)]\n  }\n\n  hasBounced(index) {\n    return (this.bounced[index] += 1)\n  }\n\n  setPosition(element, { x = 0, y = 0, z = 0 }) {\n    if (element) {\n      element.style.cssText = `transform: translate3d(${x}px, ${y}px, ${z}px);`\n    }\n  }\n\n  rigidBorders(elements) {\n    if (this.calculateBorders !== 'rigid') return\n\n    const top = this.containerOffsets.top\n    const left = this.containerOffsets.left\n    const right = this.containerOffsets.right + 1\n    const bottom = this.containerOffsets.bottom + 1\n\n    for (let index = 0; index < elements.length; index++) {\n      // Particle cinematic properties\n      const dimension = this.dimensions[index]\n      let velocity = this.velocities[index]\n      let position = this.positions[index]\n\n      // Top wall\n      if (position[1] < dimension[1] + this.container.height * top) {\n        this.hasBounced(index)\n        this.velocities[index][1] = -velocity[1]\n        this.positions[index][1] = dimension[1] + this.container.height * top\n      }\n\n      // Left wall\n      if (position[0] < dimension[0] + this.container.width * left) {\n        this.hasBounced(index)\n        this.velocities[index][0] = -velocity[0]\n        this.positions[index][0] = dimension[0] + this.container.width * left\n      }\n\n      // Bottom wall\n      if (position[1] > this.container.height * bottom - dimension[1]) {\n        this.hasBounced(index)\n        this.velocities[index][1] = -velocity[1]\n        this.positions[index][1] = this.container.height * bottom - dimension[1]\n      }\n\n      // Right wall\n      if (position[0] > this.container.width * right - dimension[0]) {\n        this.hasBounced(index)\n        this.velocities[index][0] = -velocity[0]\n        this.positions[index][0] = this.container.width * right - dimension[0]\n      }\n    }\n  }\n\n  periodicBorders(elements) {\n    if (this.calculateBorders !== 'periodic') return\n\n    const top = this.containerOffsets.top\n    const left = this.containerOffsets.left\n    const right = this.containerOffsets.right + 1\n    const bottom = this.containerOffsets.bottom + 1\n\n    for (let index = 0; index < elements.length; index++) {\n      // Particle cinematic properties\n      const dimension = this.dimensions[index]\n      let position = this.positions[index]\n      let dir = this.velocities[index].map((v) => Math.sign(v))\n\n      // Top wall\n      if (\n        dir[1] === -1 &&\n        position[1] < dimension[1] + this.container.height * top\n      ) {\n        this.positions[index][1] = dimension[1] + this.container.height * bottom\n      }\n\n      // Bottom wall\n      if (\n        dir[1] === 1 &&\n        position[1] > this.container.height * bottom - dimension[1]\n      ) {\n        this.positions[index][1] = this.container.height * top - dimension[1]\n      }\n\n      // Left wall\n      if (\n        dir[0] === -1 &&\n        position[0] < dimension[0] + this.container.width * left\n      ) {\n        this.positions[index][0] = dimension[0] + this.container.width * right\n      }\n\n      // Right wall\n      if (\n        dir[0] === 1 &&\n        position[0] > this.container.width * right - dimension[0]\n      ) {\n        this.positions[index][0] = this.container.width * left - dimension[0]\n      }\n    }\n  }\n\n  isNeighboor(current, index) {\n    const neighboorHash = this.hash[index]\n    let hashItem = this.hash[current]\n    let isNeighboor = false\n\n    for (let i = -1; i < 2; i++) {\n      for (let j = -1; j < 2; j++) {\n        let box = hashItem + this.gridSize * i + j\n\n        if (box < 0 || box > this.gridSize * this.gridSize) {\n          continue\n        }\n\n        if (box === neighboorHash) {\n          isNeighboor = true\n          break\n        }\n      }\n    }\n\n    return isNeighboor\n  }\n\n  axisAlignedBoundaryBoxes(index, idy) {\n    const dimension = this.dimensions[index]\n    const position = this.positions[index]\n\n    const neighboorDimension = this.dimensions[idy]\n    const neighboorPosition = this.positions[idy]\n\n    const overlaping = position.map(\n      (pos, idx) =>\n        Math.abs(pos - neighboorPosition[idx]) <\n        dimension[idx] + neighboorDimension[idx]\n    )\n\n    return overlaping.every((overlap) => overlap)\n  }\n\n  calculateSuperposition(index, idy) {\n    let force = [0, 0]\n\n    const posA = this.positions[index]\n    const dimA = this.dimensions[index]\n    const posB = this.positions[idy]\n    const dimB = this.dimensions[idy]\n\n    const overlaping = posA.map(\n      (pos, idx) => dimA[idx] + dimB[idx] - Math.abs(pos - posB[idx])\n    )\n\n    if (overlaping[0] < overlaping[1]) {\n      if (posA[0] < posB[0]) {\n        force[0] = overlaping[0]\n      } else {\n        force[0] = -overlaping[0]\n      }\n    } else {\n      if (posA[1] < posB[1]) {\n        force[1] = overlaping[1]\n      } else {\n        force[1] = -overlaping[1]\n      }\n    }\n\n    return force.map((f) => f + Math.random() * this.collisionRandomness)\n  }\n\n  collisions(elements) {\n    if (!this.calculatecCollisions) return\n    this.collisionsList = []\n\n    for (let index = 0; index < elements.length; index++) {\n      let velocity = this.velocities[index]\n\n      // Collisions from particle X to all other\n      this.hash.forEach((neighboorHash, idy) => {\n        //Discard same element\n        if (idy === index) return\n\n        let neighboorVelocity = this.velocities[idy]\n\n        // Collisions are pairwise so need to check if already collided\n        if (\n          this.collisionsList.some(\n            ({ loop, inHash }) => loop === idy && inHash === index\n          )\n        )\n          return\n\n        // Discard if not a neighboor\n        if (!this.isNeighboor(index, idy)) return\n\n        const hasCollision = this.axisAlignedBoundaryBoxes(index, idy)\n\n        //no colisions\n        if (!hasCollision) {\n          return\n        }\n\n        // Add to collision list\n        this.collisionsList.push({ loop: index, inHash: idy })\n\n        // Calculate initial kinetic energy\n        const initialKE =\n          0.5 *\n          (velocity.reduce((sum, v) => sum + v * v, 0) +\n            neighboorVelocity.reduce((sum, v) => sum + v * v, 0))\n\n        // Resolve superpositions\n        const exclusionForce = this.calculateSuperposition(index, idy)\n\n        // Apply superposition forces\n        let collisonVelocity = velocity.map((v, idx) => v + exclusionForce[idx])\n        let neighboorCollisionVelocity = neighboorVelocity.map(\n          (v, idx) => v - exclusionForce[idx]\n        )\n\n        // Calculate new kinetic energy\n        const finalKE =\n          0.5 *\n          (collisonVelocity.reduce((sum, v) => sum + v * v, 0) +\n            neighboorCollisionVelocity.reduce((sum, v) => sum + v * v, 0))\n\n        // Scale velocities to conserve energy\n        if (finalKE !== 0) {\n          const scale = Math.sqrt(initialKE / finalKE)\n          collisonVelocity = collisonVelocity.map((v) => v * scale)\n          neighboorCollisionVelocity = neighboorCollisionVelocity.map(\n            (v) => v * scale\n          )\n        }\n\n        // Swap velocities\n        this.velocities[index] = neighboorCollisionVelocity\n        this.velocities[idy] = collisonVelocity\n      })\n    }\n  }\n\n  update(elements, callback) {\n    this.rigidBorders(elements)\n    this.periodicBorders(elements)\n    this.collisions(elements)\n    callback(this)\n\n    this.positions.forEach((pos, index) => {\n      this.hash[index] =\n        Math.floor((this.gridSize * pos[0]) / this.container.width) +\n        Math.floor((this.gridSize * pos[1]) / this.container.height) *\n          this.gridSize\n    })\n  }\n}\n"],"names":["ElasticCollision","constructor","gridSize","containerOffsets","top","bottom","left","right","collisions","borders","collisionRandomness","this","calculatecCollisions","calculateBorders","positions","velocities","externalForces","dimensions","bounced","hash","container","collisionsList","initialConditions","elements","rect","callback","map","element","index","elementRect","width","height","forEach","pos","Math","floor","setPosition","x","y","polarCoordinates","vector","speed","sqrt","angle","atan2","cartesianCoordinates","cos","sin","hasBounced","z","style","cssText","rigidBorders","length","dimension","velocity","position","periodicBorders","dir","v","sign","isNeighboor","current","neighboorHash","hashItem","i","j","box","axisAlignedBoundaryBoxes","idy","neighboorDimension","neighboorPosition","idx","abs","every","overlap","calculateSuperposition","force","posA","dimA","posB","dimB","overlaping","f","random","neighboorVelocity","some","loop","inHash","push","initialKE","reduce","sum","exclusionForce","collisonVelocity","neighboorCollisionVelocity","finalKE","scale","update"],"mappings":"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"}