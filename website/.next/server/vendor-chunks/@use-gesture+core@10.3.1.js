/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@use-gesture+core@10.3.1";
exports.ids = ["vendor-chunks/@use-gesture+core@10.3.1"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigResolverMap: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   EngineMap: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   dragAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   hoverAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   moveAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   pinchAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   registerAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   scrollAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   wheelAction: () => (/* reexport safe */ _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _dist_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/actions-fe213e88.esm.js */ \"(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucy9kaXN0L3VzZS1nZXN0dXJlLWNvcmUtYWN0aW9ucy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0TjtBQUNsTCIsInNvdXJjZXMiOlsid2VicGFjazovL0BkYXJrcm9vbS5lbmdpbmVlcmluZy9zYXR1cy8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVzZS1nZXN0dXJlK2NvcmVAMTAuMy4xL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9hY3Rpb25zL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS1hY3Rpb25zLmVzbS5qcz85M2U0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEMgYXMgQ29uZmlnUmVzb2x2ZXJNYXAsIEUgYXMgRW5naW5lTWFwLCBlIGFzIGRyYWdBY3Rpb24sIGggYXMgaG92ZXJBY3Rpb24sIG0gYXMgbW92ZUFjdGlvbiwgZiBhcyBwaW5jaEFjdGlvbiwgciBhcyByZWdpc3RlckFjdGlvbiwgcyBhcyBzY3JvbGxBY3Rpb24sIHcgYXMgd2hlZWxBY3Rpb24gfSBmcm9tICcuLi8uLi9kaXN0L2FjdGlvbnMtZmUyMTNlODguZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ ConfigResolverMap),\n/* harmony export */   E: () => (/* binding */ EngineMap),\n/* harmony export */   S: () => (/* binding */ SUPPORT),\n/* harmony export */   _: () => (/* binding */ _objectSpread2),\n/* harmony export */   a: () => (/* binding */ _defineProperty),\n/* harmony export */   b: () => (/* binding */ touchIds),\n/* harmony export */   c: () => (/* binding */ chain),\n/* harmony export */   d: () => (/* binding */ toHandlerProp),\n/* harmony export */   e: () => (/* binding */ dragAction),\n/* harmony export */   f: () => (/* binding */ pinchAction),\n/* harmony export */   h: () => (/* binding */ hoverAction),\n/* harmony export */   i: () => (/* binding */ isTouch),\n/* harmony export */   m: () => (/* binding */ moveAction),\n/* harmony export */   p: () => (/* binding */ parseProp),\n/* harmony export */   r: () => (/* binding */ registerAction),\n/* harmony export */   s: () => (/* binding */ scrollAction),\n/* harmony export */   t: () => (/* binding */ toDomEventType),\n/* harmony export */   w: () => (/* binding */ wheelAction)\n/* harmony export */ });\n/* harmony import */ var _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maths-0ab39ae9.esm.js */ \"(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nconst actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  try {\n    const dx = P2.clientX - P1.clientX;\n    const dy = P2.clientY - P1.clientY;\n    const cx = (P2.clientX + P1.clientX) / 2;\n    const cy = (P2.clientY + P1.clientY) / 2;\n    const distance = Math.hypot(dx, dy);\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n    const origin = [cx, cy];\n    return {\n      angle,\n      distance,\n      origin\n    };\n  } catch (_unused) {}\n  return null;\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = state.timeDelta = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = (0,_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(state._bounds, state.offset, rubberband);\n    state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        state.timeDelta = dt;\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (true) {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, 0);\n  }\n};\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n    if ('current' in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],\n  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],\n  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],\n  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (true) {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [_dx, _dy] = state._delta;\n      const [_mx, _my] = state._movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        const _vx = Math.abs(_dx / state.timeDelta);\n        const _vy = Math.abs(_dy / state.timeDelta);\n        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);\n        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (true) {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(this.config.keyboardDisplacement, factor);\n      state._keyboardActive = true;\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction('key', 'down', this.keyDown.bind(this));\n      bindFunction('key', 'up', this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n}\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: supportsTouchEvents(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_KEYBOARD_DISPLACEMENT = 10;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(velocity)),\n      distance: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  },\n  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {\n    return value;\n  }\n});\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'pinching');\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === 'wheel') {\n      this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active) return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find(k => event[k]) : !event[modifierKey])) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if ( true && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9hY3Rpb25zLWZlMjEzZTg4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBaUI7QUFDcEMsa0JBQWtCLHFEQUFDO0FBQ25CO0FBQ0E7QUFDQSxvQkFBb0IscURBQUM7QUFDckI7QUFDQSxNQUFNLHFEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxxQkFBcUI7QUFDbEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQUM7QUFDekI7QUFDQTtBQUNBLDBCQUEwQixxREFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwyQ0FBMkM7QUFDM0MsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixxREFBQztBQUMvQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxLQUFLLEdBQUcsSUFBSTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxxREFBQztBQUNaO0FBQ0E7QUFDQSxJQUFJLElBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEdBQThHLGNBQWM7QUFDNUg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxrRUFBa0UsMkJBQTJCO0FBQzdGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIscURBQUM7QUFDdEI7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxJQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHFEQUFDO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0EsK0JBQStCLHFEQUFDO0FBQ2hDLCtCQUErQixxREFBQztBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsSUFBSSxJQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVyxlQUFlO0FBQzNJO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUhBQXVILFNBQVMsaUJBQWlCO0FBQ2pKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVIQUF1SCxTQUFTLGdCQUFnQjtBQUNoSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1SEFBdUgsU0FBUyxpQkFBaUI7QUFDako7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBCQUEwQixxREFBQztBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQsMkJBQTJCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixxREFBQztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBQztBQUNwQixJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxnQ0FBZ0M7QUFDM0Y7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUM7QUFDcEIsSUFBSSxxREFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscURBQUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELGdDQUFnQztBQUM1RjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2VSIsInNvdXJjZXMiOlsid2VicGFjazovL0BkYXJrcm9vbS5lbmdpbmVlcmluZy9zYXR1cy8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVzZS1nZXN0dXJlK2NvcmVAMTAuMy4xL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9kaXN0L2FjdGlvbnMtZmUyMTNlODguZXNtLmpzPzA3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgViwgYyBhcyBjb21wdXRlUnViYmVyYmFuZCB9IGZyb20gJy4vbWF0aHMtMGFiMzlhZTkuZXNtLmpzJztcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmNvbnN0IEVWRU5UX1RZUEVfTUFQID0ge1xuICBwb2ludGVyOiB7XG4gICAgc3RhcnQ6ICdkb3duJyxcbiAgICBjaGFuZ2U6ICdtb3ZlJyxcbiAgICBlbmQ6ICd1cCdcbiAgfSxcbiAgbW91c2U6IHtcbiAgICBzdGFydDogJ2Rvd24nLFxuICAgIGNoYW5nZTogJ21vdmUnLFxuICAgIGVuZDogJ3VwJ1xuICB9LFxuICB0b3VjaDoge1xuICAgIHN0YXJ0OiAnc3RhcnQnLFxuICAgIGNoYW5nZTogJ21vdmUnLFxuICAgIGVuZDogJ2VuZCdcbiAgfSxcbiAgZ2VzdHVyZToge1xuICAgIHN0YXJ0OiAnc3RhcnQnLFxuICAgIGNoYW5nZTogJ2NoYW5nZScsXG4gICAgZW5kOiAnZW5kJ1xuICB9XG59O1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgaWYgKCFzdHJpbmcpIHJldHVybiAnJztcbiAgcmV0dXJuIHN0cmluZ1swXS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuY29uc3QgYWN0aW9uc1dpdGhvdXRDYXB0dXJlU3VwcG9ydGVkID0gWydlbnRlcicsICdsZWF2ZSddO1xuZnVuY3Rpb24gaGFzQ2FwdHVyZShjYXB0dXJlID0gZmFsc2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gY2FwdHVyZSAmJiAhYWN0aW9uc1dpdGhvdXRDYXB0dXJlU3VwcG9ydGVkLmluY2x1ZGVzKGFjdGlvbktleSk7XG59XG5mdW5jdGlvbiB0b0hhbmRsZXJQcm9wKGRldmljZSwgYWN0aW9uID0gJycsIGNhcHR1cmUgPSBmYWxzZSkge1xuICBjb25zdCBkZXZpY2VQcm9wcyA9IEVWRU5UX1RZUEVfTUFQW2RldmljZV07XG4gIGNvbnN0IGFjdGlvbktleSA9IGRldmljZVByb3BzID8gZGV2aWNlUHJvcHNbYWN0aW9uXSB8fCBhY3Rpb24gOiBhY3Rpb247XG4gIHJldHVybiAnb24nICsgY2FwaXRhbGl6ZShkZXZpY2UpICsgY2FwaXRhbGl6ZShhY3Rpb25LZXkpICsgKGhhc0NhcHR1cmUoY2FwdHVyZSwgYWN0aW9uS2V5KSA/ICdDYXB0dXJlJyA6ICcnKTtcbn1cbmNvbnN0IHBvaW50ZXJDYXB0dXJlRXZlbnRzID0gWydnb3Rwb2ludGVyY2FwdHVyZScsICdsb3N0cG9pbnRlcmNhcHR1cmUnXTtcbmZ1bmN0aW9uIHBhcnNlUHJvcChwcm9wKSB7XG4gIGxldCBldmVudEtleSA9IHByb3Auc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHBhc3NpdmUgPSAhIX5ldmVudEtleS5pbmRleE9mKCdwYXNzaXZlJyk7XG4gIGlmIChwYXNzaXZlKSBldmVudEtleSA9IGV2ZW50S2V5LnJlcGxhY2UoJ3Bhc3NpdmUnLCAnJyk7XG4gIGNvbnN0IGNhcHR1cmVLZXkgPSBwb2ludGVyQ2FwdHVyZUV2ZW50cy5pbmNsdWRlcyhldmVudEtleSkgPyAnY2FwdHVyZWNhcHR1cmUnIDogJ2NhcHR1cmUnO1xuICBjb25zdCBjYXB0dXJlID0gISF+ZXZlbnRLZXkuaW5kZXhPZihjYXB0dXJlS2V5KTtcbiAgaWYgKGNhcHR1cmUpIGV2ZW50S2V5ID0gZXZlbnRLZXkucmVwbGFjZSgnY2FwdHVyZScsICcnKTtcbiAgcmV0dXJuIHtcbiAgICBkZXZpY2U6IGV2ZW50S2V5LFxuICAgIGNhcHR1cmUsXG4gICAgcGFzc2l2ZVxuICB9O1xufVxuZnVuY3Rpb24gdG9Eb21FdmVudFR5cGUoZGV2aWNlLCBhY3Rpb24gPSAnJykge1xuICBjb25zdCBkZXZpY2VQcm9wcyA9IEVWRU5UX1RZUEVfTUFQW2RldmljZV07XG4gIGNvbnN0IGFjdGlvbktleSA9IGRldmljZVByb3BzID8gZGV2aWNlUHJvcHNbYWN0aW9uXSB8fCBhY3Rpb24gOiBhY3Rpb247XG4gIHJldHVybiBkZXZpY2UgKyBhY3Rpb25LZXk7XG59XG5mdW5jdGlvbiBpc1RvdWNoKGV2ZW50KSB7XG4gIHJldHVybiAndG91Y2hlcycgaW4gZXZlbnQ7XG59XG5mdW5jdGlvbiBnZXRQb2ludGVyVHlwZShldmVudCkge1xuICBpZiAoaXNUb3VjaChldmVudCkpIHJldHVybiAndG91Y2gnO1xuICBpZiAoJ3BvaW50ZXJUeXBlJyBpbiBldmVudCkgcmV0dXJuIGV2ZW50LnBvaW50ZXJUeXBlO1xuICByZXR1cm4gJ21vdXNlJztcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUYXJnZXRUb3VjaExpc3QoZXZlbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnQudG91Y2hlcykuZmlsdGVyKGUgPT4ge1xuICAgIHZhciBfZXZlbnQkY3VycmVudFRhcmdldCwgX2V2ZW50JGN1cnJlbnRUYXJnZXQkO1xuICAgIHJldHVybiBlLnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCB8fCAoKF9ldmVudCRjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCkgPT09IG51bGwgfHwgX2V2ZW50JGN1cnJlbnRUYXJnZXQgPT09IHZvaWQgMCB8fCAoX2V2ZW50JGN1cnJlbnRUYXJnZXQkID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuY29udGFpbnMpID09PSBudWxsIHx8IF9ldmVudCRjdXJyZW50VGFyZ2V0JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50JGN1cnJlbnRUYXJnZXQkLmNhbGwoX2V2ZW50JGN1cnJlbnRUYXJnZXQsIGUudGFyZ2V0KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaGNhbmNlbCcgPyBldmVudC5jaGFuZ2VkVG91Y2hlcyA6IGV2ZW50LnRhcmdldFRvdWNoZXM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBpc1RvdWNoKGV2ZW50KSA/IGdldFRvdWNoTGlzdChldmVudClbMF0gOiBldmVudDtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQW5nbGUoUDEsIFAyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZHggPSBQMi5jbGllbnRYIC0gUDEuY2xpZW50WDtcbiAgICBjb25zdCBkeSA9IFAyLmNsaWVudFkgLSBQMS5jbGllbnRZO1xuICAgIGNvbnN0IGN4ID0gKFAyLmNsaWVudFggKyBQMS5jbGllbnRYKSAvIDI7XG4gICAgY29uc3QgY3kgPSAoUDIuY2xpZW50WSArIFAxLmNsaWVudFkpIC8gMjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgICBjb25zdCBhbmdsZSA9IC0oTWF0aC5hdGFuMihkeCwgZHkpICogMTgwKSAvIE1hdGguUEk7XG4gICAgY29uc3Qgb3JpZ2luID0gW2N4LCBjeV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuZ2xlLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBvcmlnaW5cbiAgICB9O1xuICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRvdWNoSWRzKGV2ZW50KSB7XG4gIHJldHVybiBnZXRDdXJyZW50VGFyZ2V0VG91Y2hMaXN0KGV2ZW50KS5tYXAodG91Y2ggPT4gdG91Y2guaWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiB0b3VjaERpc3RhbmNlQW5nbGUoZXZlbnQsIGlkcykge1xuICBjb25zdCBbUDEsIFAyXSA9IEFycmF5LmZyb20oZXZlbnQudG91Y2hlcykuZmlsdGVyKHRvdWNoID0+IGlkcy5pbmNsdWRlcyh0b3VjaC5pZGVudGlmaWVyKSk7XG4gIHJldHVybiBkaXN0YW5jZUFuZ2xlKFAxLCBQMik7XG59XG5mdW5jdGlvbiBwb2ludGVySWQoZXZlbnQpIHtcbiAgY29uc3QgdmFsdWVFdmVudCA9IGdldFZhbHVlRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gaXNUb3VjaChldmVudCkgPyB2YWx1ZUV2ZW50LmlkZW50aWZpZXIgOiB2YWx1ZUV2ZW50LnBvaW50ZXJJZDtcbn1cbmZ1bmN0aW9uIHBvaW50ZXJWYWx1ZXMoZXZlbnQpIHtcbiAgY29uc3QgdmFsdWVFdmVudCA9IGdldFZhbHVlRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gW3ZhbHVlRXZlbnQuY2xpZW50WCwgdmFsdWVFdmVudC5jbGllbnRZXTtcbn1cbmNvbnN0IExJTkVfSEVJR0hUID0gNDA7XG5jb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcbmZ1bmN0aW9uIHdoZWVsVmFsdWVzKGV2ZW50KSB7XG4gIGxldCB7XG4gICAgZGVsdGFYLFxuICAgIGRlbHRhWSxcbiAgICBkZWx0YU1vZGVcbiAgfSA9IGV2ZW50O1xuICBpZiAoZGVsdGFNb2RlID09PSAxKSB7XG4gICAgZGVsdGFYICo9IExJTkVfSEVJR0hUO1xuICAgIGRlbHRhWSAqPSBMSU5FX0hFSUdIVDtcbiAgfSBlbHNlIGlmIChkZWx0YU1vZGUgPT09IDIpIHtcbiAgICBkZWx0YVggKj0gUEFHRV9IRUlHSFQ7XG4gICAgZGVsdGFZICo9IFBBR0VfSEVJR0hUO1xuICB9XG4gIHJldHVybiBbZGVsdGFYLCBkZWx0YVldO1xufVxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVzKGV2ZW50KSB7XG4gIHZhciBfcmVmLCBfcmVmMjtcbiAgY29uc3Qge1xuICAgIHNjcm9sbFgsXG4gICAgc2Nyb2xsWSxcbiAgICBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcFxuICB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgcmV0dXJuIFsoX3JlZiA9IHNjcm9sbFggIT09IG51bGwgJiYgc2Nyb2xsWCAhPT0gdm9pZCAwID8gc2Nyb2xsWCA6IHNjcm9sbExlZnQpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAwLCAoX3JlZjIgPSBzY3JvbGxZICE9PSBudWxsICYmIHNjcm9sbFkgIT09IHZvaWQgMCA/IHNjcm9sbFkgOiBzY3JvbGxUb3ApICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IDBdO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnREZXRhaWxzKGV2ZW50KSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgaWYgKCdidXR0b25zJyBpbiBldmVudCkgcGF5bG9hZC5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcbiAgaWYgKCdzaGlmdEtleScgaW4gZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGlmdEtleSxcbiAgICAgIGFsdEtleSxcbiAgICAgIG1ldGFLZXksXG4gICAgICBjdHJsS2V5XG4gICAgfSA9IGV2ZW50O1xuICAgIE9iamVjdC5hc3NpZ24ocGF5bG9hZCwge1xuICAgICAgc2hpZnRLZXksXG4gICAgICBhbHRLZXksXG4gICAgICBtZXRhS2V5LFxuICAgICAgY3RybEtleVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBjYWxsKHYsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHYoLi4uYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gY2hhaW4oLi4uZm5zKSB7XG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSByZXR1cm4gbm9vcDtcbiAgaWYgKGZucy5sZW5ndGggPT09IDEpIHJldHVybiBmbnNbMF07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KHZhbHVlLCBmYWxsYmFjaykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmFsbGJhY2ssIHZhbHVlIHx8IHt9KTtcbn1cblxuY29uc3QgQkVGT1JFX0xBU1RfS0lORU1BVElDU19ERUxBWSA9IDMyO1xuY2xhc3MgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoY3RybCwgYXJncywga2V5KSB7XG4gICAgdGhpcy5jdHJsID0gY3RybDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgdGhpcy5jb21wdXRlVmFsdWVzKFswLCAwXSk7XG4gICAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuc3RhdGVbdGhpcy5rZXldO1xuICB9XG4gIHNldCBzdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuY3RybC5zdGF0ZVt0aGlzLmtleV0gPSBzdGF0ZTtcbiAgfVxuICBnZXQgc2hhcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuc3RhdGUuc2hhcmVkO1xuICB9XG4gIGdldCBldmVudFN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuZ2VzdHVyZUV2ZW50U3RvcmVzW3RoaXMua2V5XTtcbiAgfVxuICBnZXQgdGltZW91dFN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuZ2VzdHVyZVRpbWVvdXRTdG9yZXNbdGhpcy5rZXldO1xuICB9XG4gIGdldCBjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5jb25maWdbdGhpcy5rZXldO1xuICB9XG4gIGdldCBzaGFyZWRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5jb25maWcuc2hhcmVkO1xuICB9XG4gIGdldCBoYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuaGFuZGxlcnNbdGhpcy5rZXldO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2hhcmVkLFxuICAgICAgaW5nS2V5LFxuICAgICAgYXJnc1xuICAgIH0gPSB0aGlzO1xuICAgIHNoYXJlZFtpbmdLZXldID0gc3RhdGUuX2FjdGl2ZSA9IHN0YXRlLmFjdGl2ZSA9IHN0YXRlLl9ibG9ja2VkID0gc3RhdGUuX2ZvcmNlID0gZmFsc2U7XG4gICAgc3RhdGUuX3N0ZXAgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBzdGF0ZS5pbnRlbnRpb25hbCA9IGZhbHNlO1xuICAgIHN0YXRlLl9tb3ZlbWVudCA9IFswLCAwXTtcbiAgICBzdGF0ZS5fZGlzdGFuY2UgPSBbMCwgMF07XG4gICAgc3RhdGUuX2RpcmVjdGlvbiA9IFswLCAwXTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBbMCwgMF07XG4gICAgc3RhdGUuX2JvdW5kcyA9IFtbLUluZmluaXR5LCBJbmZpbml0eV0sIFstSW5maW5pdHksIEluZmluaXR5XV07XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5tZW1vID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLmVsYXBzZWRUaW1lID0gc3RhdGUudGltZURlbHRhID0gMDtcbiAgICBzdGF0ZS5kaXJlY3Rpb24gPSBbMCwgMF07XG4gICAgc3RhdGUuZGlzdGFuY2UgPSBbMCwgMF07XG4gICAgc3RhdGUub3ZlcmZsb3cgPSBbMCwgMF07XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBzdGF0ZS52ZWxvY2l0eSA9IFswLCAwXTtcbiAgICBzdGF0ZS5tb3ZlbWVudCA9IFswLCAwXTtcbiAgICBzdGF0ZS5kZWx0YSA9IFswLCAwXTtcbiAgICBzdGF0ZS50aW1lU3RhbXAgPSAwO1xuICB9XG4gIHN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IHRydWU7XG4gICAgICBzdGF0ZS50YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBzdGF0ZS5jdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIHN0YXRlLmxhc3RPZmZzZXQgPSBjb25maWcuZnJvbSA/IGNhbGwoY29uZmlnLmZyb20sIHN0YXRlKSA6IHN0YXRlLm9mZnNldDtcbiAgICAgIHN0YXRlLm9mZnNldCA9IHN0YXRlLmxhc3RPZmZzZXQ7XG4gICAgICBzdGF0ZS5zdGFydFRpbWUgPSBzdGF0ZS50aW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVWYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgc3RhdGUudmFsdWVzID0gdGhpcy5jb25maWcudHJhbnNmb3JtKHZhbHVlcyk7XG4gIH1cbiAgY29tcHV0ZUluaXRpYWwoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9pbml0aWFsID0gc3RhdGUuX3ZhbHVlcztcbiAgICBzdGF0ZS5pbml0aWFsID0gc3RhdGUudmFsdWVzO1xuICB9XG4gIGNvbXB1dGUoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHNoYXJlZFxuICAgIH0gPSB0aGlzO1xuICAgIHN0YXRlLmFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGR0ID0gMDtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIHN0YXRlLmV2ZW50ID0gZXZlbnQ7XG4gICAgICBpZiAoY29uZmlnLnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LmNhbmNlbGFibGUpIHN0YXRlLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdGF0ZS50eXBlID0gZXZlbnQudHlwZTtcbiAgICAgIHNoYXJlZC50b3VjaGVzID0gdGhpcy5jdHJsLnBvaW50ZXJJZHMuc2l6ZSB8fCB0aGlzLmN0cmwudG91Y2hJZHMuc2l6ZTtcbiAgICAgIHNoYXJlZC5sb2NrZWQgPSAhIWRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgIE9iamVjdC5hc3NpZ24oc2hhcmVkLCBnZXRFdmVudERldGFpbHMoZXZlbnQpKTtcbiAgICAgIHNoYXJlZC5kb3duID0gc2hhcmVkLnByZXNzZWQgPSBzaGFyZWQuYnV0dG9ucyAlIDIgPT09IDEgfHwgc2hhcmVkLnRvdWNoZXMgPiAwO1xuICAgICAgZHQgPSBldmVudC50aW1lU3RhbXAgLSBzdGF0ZS50aW1lU3RhbXA7XG4gICAgICBzdGF0ZS50aW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICBzdGF0ZS5lbGFwc2VkVGltZSA9IHN0YXRlLnRpbWVTdGFtcCAtIHN0YXRlLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IF9hYnNvbHV0ZURlbHRhID0gc3RhdGUuX2RlbHRhLm1hcChNYXRoLmFicyk7XG4gICAgICBWLmFkZFRvKHN0YXRlLl9kaXN0YW5jZSwgX2Fic29sdXRlRGVsdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzSW50ZW50KSB0aGlzLmF4aXNJbnRlbnQoZXZlbnQpO1xuICAgIGNvbnN0IFtfbTAsIF9tMV0gPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgY29uc3QgW3QwLCB0MV0gPSBjb25maWcudGhyZXNob2xkO1xuICAgIGNvbnN0IHtcbiAgICAgIF9zdGVwLFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmIChjb25maWcuaGFzQ3VzdG9tVHJhbnNmb3JtKSB7XG4gICAgICBpZiAoX3N0ZXBbMF0gPT09IGZhbHNlKSBfc3RlcFswXSA9IE1hdGguYWJzKF9tMCkgPj0gdDAgJiYgdmFsdWVzWzBdO1xuICAgICAgaWYgKF9zdGVwWzFdID09PSBmYWxzZSkgX3N0ZXBbMV0gPSBNYXRoLmFicyhfbTEpID49IHQxICYmIHZhbHVlc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9zdGVwWzBdID09PSBmYWxzZSkgX3N0ZXBbMF0gPSBNYXRoLmFicyhfbTApID49IHQwICYmIE1hdGguc2lnbihfbTApICogdDA7XG4gICAgICBpZiAoX3N0ZXBbMV0gPT09IGZhbHNlKSBfc3RlcFsxXSA9IE1hdGguYWJzKF9tMSkgPj0gdDEgJiYgTWF0aC5zaWduKF9tMSkgKiB0MTtcbiAgICB9XG4gICAgc3RhdGUuaW50ZW50aW9uYWwgPSBfc3RlcFswXSAhPT0gZmFsc2UgfHwgX3N0ZXBbMV0gIT09IGZhbHNlO1xuICAgIGlmICghc3RhdGUuaW50ZW50aW9uYWwpIHJldHVybjtcbiAgICBjb25zdCBtb3ZlbWVudCA9IFswLCAwXTtcbiAgICBpZiAoY29uZmlnLmhhc0N1c3RvbVRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgW3YwLCB2MV0gPSB2YWx1ZXM7XG4gICAgICBtb3ZlbWVudFswXSA9IF9zdGVwWzBdICE9PSBmYWxzZSA/IHYwIC0gX3N0ZXBbMF0gOiAwO1xuICAgICAgbW92ZW1lbnRbMV0gPSBfc3RlcFsxXSAhPT0gZmFsc2UgPyB2MSAtIF9zdGVwWzFdIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnRbMF0gPSBfc3RlcFswXSAhPT0gZmFsc2UgPyBfbTAgLSBfc3RlcFswXSA6IDA7XG4gICAgICBtb3ZlbWVudFsxXSA9IF9zdGVwWzFdICE9PSBmYWxzZSA/IF9tMSAtIF9zdGVwWzFdIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzdHJpY3RUb0F4aXMgJiYgIXN0YXRlLl9ibG9ja2VkKSB0aGlzLnJlc3RyaWN0VG9BeGlzKG1vdmVtZW50KTtcbiAgICBjb25zdCBwcmV2aW91c09mZnNldCA9IHN0YXRlLm9mZnNldDtcbiAgICBjb25zdCBnZXN0dXJlSXNBY3RpdmUgPSBzdGF0ZS5fYWN0aXZlICYmICFzdGF0ZS5fYmxvY2tlZCB8fCBzdGF0ZS5hY3RpdmU7XG4gICAgaWYgKGdlc3R1cmVJc0FjdGl2ZSkge1xuICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5fYWN0aXZlICYmICFzdGF0ZS5hY3RpdmU7XG4gICAgICBzdGF0ZS5sYXN0ID0gIXN0YXRlLl9hY3RpdmUgJiYgc3RhdGUuYWN0aXZlO1xuICAgICAgc3RhdGUuYWN0aXZlID0gc2hhcmVkW3RoaXMuaW5nS2V5XSA9IHN0YXRlLl9hY3RpdmU7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgaWYgKCdib3VuZHMnIGluIGNvbmZpZykgc3RhdGUuX2JvdW5kcyA9IGNhbGwoY29uZmlnLmJvdW5kcywgc3RhdGUpO1xuICAgICAgICAgIGlmICh0aGlzLnNldHVwKSB0aGlzLnNldHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW92ZW1lbnQgPSBtb3ZlbWVudDtcbiAgICAgICAgdGhpcy5jb21wdXRlT2Zmc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtveCwgb3ldID0gc3RhdGUub2Zmc2V0O1xuICAgIGNvbnN0IFtbeDAsIHgxXSwgW3kwLCB5MV1dID0gc3RhdGUuX2JvdW5kcztcbiAgICBzdGF0ZS5vdmVyZmxvdyA9IFtveCA8IHgwID8gLTEgOiBveCA+IHgxID8gMSA6IDAsIG95IDwgeTAgPyAtMSA6IG95ID4geTEgPyAxIDogMF07XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmRbMF0gPSBzdGF0ZS5vdmVyZmxvd1swXSA/IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdID09PSBmYWxzZSA/IHN0YXRlLl9tb3ZlbWVudFswXSA6IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdIDogZmFsc2U7XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmRbMV0gPSBzdGF0ZS5vdmVyZmxvd1sxXSA/IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdID09PSBmYWxzZSA/IHN0YXRlLl9tb3ZlbWVudFsxXSA6IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdIDogZmFsc2U7XG4gICAgY29uc3QgcnViYmVyYmFuZCA9IHN0YXRlLl9hY3RpdmUgPyBjb25maWcucnViYmVyYmFuZCB8fCBbMCwgMF0gOiBbMCwgMF07XG4gICAgc3RhdGUub2Zmc2V0ID0gY29tcHV0ZVJ1YmJlcmJhbmQoc3RhdGUuX2JvdW5kcywgc3RhdGUub2Zmc2V0LCBydWJiZXJiYW5kKTtcbiAgICBzdGF0ZS5kZWx0YSA9IFYuc3ViKHN0YXRlLm9mZnNldCwgcHJldmlvdXNPZmZzZXQpO1xuICAgIHRoaXMuY29tcHV0ZU1vdmVtZW50KCk7XG4gICAgaWYgKGdlc3R1cmVJc0FjdGl2ZSAmJiAoIXN0YXRlLmxhc3QgfHwgZHQgPiBCRUZPUkVfTEFTVF9LSU5FTUFUSUNTX0RFTEFZKSkge1xuICAgICAgc3RhdGUuZGVsdGEgPSBWLnN1YihzdGF0ZS5vZmZzZXQsIHByZXZpb3VzT2Zmc2V0KTtcbiAgICAgIGNvbnN0IGFic29sdXRlRGVsdGEgPSBzdGF0ZS5kZWx0YS5tYXAoTWF0aC5hYnMpO1xuICAgICAgVi5hZGRUbyhzdGF0ZS5kaXN0YW5jZSwgYWJzb2x1dGVEZWx0YSk7XG4gICAgICBzdGF0ZS5kaXJlY3Rpb24gPSBzdGF0ZS5kZWx0YS5tYXAoTWF0aC5zaWduKTtcbiAgICAgIHN0YXRlLl9kaXJlY3Rpb24gPSBzdGF0ZS5fZGVsdGEubWFwKE1hdGguc2lnbik7XG4gICAgICBpZiAoIXN0YXRlLmZpcnN0ICYmIGR0ID4gMCkge1xuICAgICAgICBzdGF0ZS52ZWxvY2l0eSA9IFthYnNvbHV0ZURlbHRhWzBdIC8gZHQsIGFic29sdXRlRGVsdGFbMV0gLyBkdF07XG4gICAgICAgIHN0YXRlLnRpbWVEZWx0YSA9IGR0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbWl0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzaGFyZWQgPSB0aGlzLnNoYXJlZDtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUpIHRoaXMuY2xlYW4oKTtcbiAgICBpZiAoKHN0YXRlLl9ibG9ja2VkIHx8ICFzdGF0ZS5pbnRlbnRpb25hbCkgJiYgIXN0YXRlLl9mb3JjZSAmJiAhY29uZmlnLnRyaWdnZXJBbGxFdmVudHMpIHJldHVybjtcbiAgICBjb25zdCBtZW1vID0gdGhpcy5oYW5kbGVyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzaGFyZWQpLCBzdGF0ZSksIHt9LCB7XG4gICAgICBbdGhpcy5hbGlhc0tleV06IHN0YXRlLnZhbHVlc1xuICAgIH0pKTtcbiAgICBpZiAobWVtbyAhPT0gdW5kZWZpbmVkKSBzdGF0ZS5tZW1vID0gbWVtbztcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLmV2ZW50U3RvcmUuY2xlYW4oKTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5jbGVhbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEF4aXMoW2R4LCBkeV0sIHRocmVzaG9sZCkge1xuICBjb25zdCBhYnNEeCA9IE1hdGguYWJzKGR4KTtcbiAgY29uc3QgYWJzRHkgPSBNYXRoLmFicyhkeSk7XG4gIGlmIChhYnNEeCA+IGFic0R5ICYmIGFic0R4ID4gdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAoYWJzRHkgPiBhYnNEeCAmJiBhYnNEeSA+IHRocmVzaG9sZCkge1xuICAgIHJldHVybiAneSc7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIENvb3JkaW5hdGVzRW5naW5lIGV4dGVuZHMgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaWFzS2V5XCIsICd4eScpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGF0ZS5heGlzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBbMCwgMF07XG4gICAgdGhpcy5zdGF0ZS5sYXN0T2Zmc2V0ID0gWzAsIDBdO1xuICB9XG4gIGNvbXB1dGVPZmZzZXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBWLmFkZCh0aGlzLnN0YXRlLmxhc3RPZmZzZXQsIHRoaXMuc3RhdGUubW92ZW1lbnQpO1xuICB9XG4gIGNvbXB1dGVNb3ZlbWVudCgpIHtcbiAgICB0aGlzLnN0YXRlLm1vdmVtZW50ID0gVi5zdWIodGhpcy5zdGF0ZS5vZmZzZXQsIHRoaXMuc3RhdGUubGFzdE9mZnNldCk7XG4gIH1cbiAgYXhpc0ludGVudChldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLmF4aXMgJiYgZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBjb25maWcuYXhpc1RocmVzaG9sZCA9PT0gJ29iamVjdCcgPyBjb25maWcuYXhpc1RocmVzaG9sZFtnZXRQb2ludGVyVHlwZShldmVudCldIDogY29uZmlnLmF4aXNUaHJlc2hvbGQ7XG4gICAgICBzdGF0ZS5heGlzID0gc2VsZWN0QXhpcyhzdGF0ZS5fbW92ZW1lbnQsIHRocmVzaG9sZCk7XG4gICAgfVxuICAgIHN0YXRlLl9ibG9ja2VkID0gKGNvbmZpZy5sb2NrRGlyZWN0aW9uIHx8ICEhY29uZmlnLmF4aXMpICYmICFzdGF0ZS5heGlzIHx8ICEhY29uZmlnLmF4aXMgJiYgY29uZmlnLmF4aXMgIT09IHN0YXRlLmF4aXM7XG4gIH1cbiAgcmVzdHJpY3RUb0F4aXModikge1xuICAgIGlmICh0aGlzLmNvbmZpZy5heGlzIHx8IHRoaXMuY29uZmlnLmxvY2tEaXJlY3Rpb24pIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5heGlzKSB7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIHZbMV0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICB2WzBdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaWRlbnRpdHkgPSB2ID0+IHY7XG5jb25zdCBERUZBVUxUX1JVQkJFUkJBTkQgPSAwLjE1O1xuY29uc3QgY29tbW9uQ29uZmlnUmVzb2x2ZXIgPSB7XG4gIGVuYWJsZWQodmFsdWUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBldmVudE9wdGlvbnModmFsdWUsIF9rLCBjb25maWcpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbmZpZy5zaGFyZWQuZXZlbnRPcHRpb25zKSwgdmFsdWUpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0cmlnZ2VyQWxsRXZlbnRzKHZhbHVlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHJ1YmJlcmJhbmQodmFsdWUgPSAwKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gW0RFRkFVTFRfUlVCQkVSQkFORCwgREVGQVVMVF9SVUJCRVJCQU5EXTtcbiAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVi50b1ZlY3Rvcih2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gVi50b1ZlY3Rvcih2YWx1ZSk7XG4gIH0sXG4gIHRyYW5zZm9ybSh2YWx1ZSwgX2ssIGNvbmZpZykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHZhbHVlIHx8IGNvbmZpZy5zaGFyZWQudHJhbnNmb3JtO1xuICAgIHRoaXMuaGFzQ3VzdG9tVHJhbnNmb3JtID0gISF0cmFuc2Zvcm07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbFRyYW5zZm9ybSA9IHRyYW5zZm9ybSB8fCBpZGVudGl0eTtcbiAgICAgIHJldHVybiB2ID0+IHtcbiAgICAgICAgY29uc3QgciA9IG9yaWdpbmFsVHJhbnNmb3JtKHYpO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHJbMF0pIHx8ICFpc0Zpbml0ZShyWzFdKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IGNvbmZpZy50cmFuc2Zvcm0oKSBtdXN0IHByb2R1Y2UgYSB2YWxpZCByZXN1bHQsIGJ1dCBpdCB3YXM6IFske3JbMF19LCR7WzFdfV1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm0gfHwgaWRlbnRpdHk7XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHJldHVybiBWLnRvVmVjdG9yKHZhbHVlLCAwKTtcbiAgfVxufTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBPYmplY3QuYXNzaWduKGNvbW1vbkNvbmZpZ1Jlc29sdmVyLCB7XG4gICAgZG9tVGFyZ2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGRvbVRhcmdldFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB0YXJnZXRcXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgbG9ja0RpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBsb2NrRGlyZWN0aW9uXFxgIG9wdGlvbiBoYXMgYmVlbiBtZXJnZWQgd2l0aCBcXGBheGlzXFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBheGlzOiAnbG9jaycgfVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIGluaXRpYWwodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgaW5pdGlhbFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBmcm9tXFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBERUZBVUxUX0FYSVNfVEhSRVNIT0xEID0gMDtcbmNvbnN0IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBheGlzKF92LCBfaywge1xuICAgIGF4aXNcbiAgfSkge1xuICAgIHRoaXMubG9ja0RpcmVjdGlvbiA9IGF4aXMgPT09ICdsb2NrJztcbiAgICBpZiAoIXRoaXMubG9ja0RpcmVjdGlvbikgcmV0dXJuIGF4aXM7XG4gIH0sXG4gIGF4aXNUaHJlc2hvbGQodmFsdWUgPSBERUZBVUxUX0FYSVNfVEhSRVNIT0xEKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBib3VuZHModmFsdWUgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzdGF0ZSA9PiBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyLmJvdW5kcyh2YWx1ZShzdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoJ2N1cnJlbnQnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gKCkgPT4gdmFsdWUuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQgPSAtSW5maW5pdHksXG4gICAgICByaWdodCA9IEluZmluaXR5LFxuICAgICAgdG9wID0gLUluZmluaXR5LFxuICAgICAgYm90dG9tID0gSW5maW5pdHlcbiAgICB9ID0gdmFsdWU7XG4gICAgcmV0dXJuIFtbbGVmdCwgcmlnaHRdLCBbdG9wLCBib3R0b21dXTtcbiAgfVxufSk7XG5cbmNvbnN0IEtFWVNfREVMVEFfTUFQID0ge1xuICBBcnJvd1JpZ2h0OiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbZGlzcGxhY2VtZW50ICogZmFjdG9yLCAwXSxcbiAgQXJyb3dMZWZ0OiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbLTEgKiBkaXNwbGFjZW1lbnQgKiBmYWN0b3IsIDBdLFxuICBBcnJvd1VwOiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbMCwgLTEgKiBkaXNwbGFjZW1lbnQgKiBmYWN0b3JdLFxuICBBcnJvd0Rvd246IChkaXNwbGFjZW1lbnQsIGZhY3RvciA9IDEpID0+IFswLCBkaXNwbGFjZW1lbnQgKiBmYWN0b3JdXG59O1xuY2xhc3MgRHJhZ0VuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnZHJhZ2dpbmcnKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fcG9pbnRlcklkID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLl9wb2ludGVyQWN0aXZlID0gZmFsc2U7XG4gICAgc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gICAgc3RhdGUuX3ByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgICBzdGF0ZS5fZGVsYXllZCA9IGZhbHNlO1xuICAgIHN0YXRlLnN3aXBlID0gWzAsIDBdO1xuICAgIHN0YXRlLnRhcCA9IGZhbHNlO1xuICAgIHN0YXRlLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgc3RhdGUuY2FuY2VsID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLl9ib3VuZHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgY29uc3QgYm91bmRSZWN0ID0gc3RhdGUuX2JvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBzdGF0ZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgX2JvdW5kcyA9IHtcbiAgICAgICAgbGVmdDogYm91bmRSZWN0LmxlZnQgLSB0YXJnZXRSZWN0LmxlZnQgKyBzdGF0ZS5vZmZzZXRbMF0sXG4gICAgICAgIHJpZ2h0OiBib3VuZFJlY3QucmlnaHQgLSB0YXJnZXRSZWN0LnJpZ2h0ICsgc3RhdGUub2Zmc2V0WzBdLFxuICAgICAgICB0b3A6IGJvdW5kUmVjdC50b3AgLSB0YXJnZXRSZWN0LnRvcCArIHN0YXRlLm9mZnNldFsxXSxcbiAgICAgICAgYm90dG9tOiBib3VuZFJlY3QuYm90dG9tIC0gdGFyZ2V0UmVjdC5ib3R0b20gKyBzdGF0ZS5vZmZzZXRbMV1cbiAgICAgIH07XG4gICAgICBzdGF0ZS5fYm91bmRzID0gY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlci5ib3VuZHMoX2JvdW5kcyk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNhbmNlbGVkKSByZXR1cm47XG4gICAgc3RhdGUuY2FuY2VsZWQgPSB0cnVlO1xuICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgc2V0QWN0aXZlKCkge1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IHRoaXMuc3RhdGUuX3BvaW50ZXJBY3RpdmUgfHwgdGhpcy5zdGF0ZS5fa2V5Ym9hcmRBY3RpdmU7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5wb2ludGVyQ2xlYW4oKTtcbiAgICB0aGlzLnN0YXRlLl9wb2ludGVyQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSBmYWxzZTtcbiAgICBzdXBlci5jbGVhbigpO1xuICB9XG4gIHBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChldmVudC5idXR0b25zICE9IG51bGwgJiYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnBvaW50ZXJCdXR0b25zKSA/ICFjb25maWcucG9pbnRlckJ1dHRvbnMuaW5jbHVkZXMoZXZlbnQuYnV0dG9ucykgOiBjb25maWcucG9pbnRlckJ1dHRvbnMgIT09IC0xICYmIGNvbmZpZy5wb2ludGVyQnV0dG9ucyAhPT0gZXZlbnQuYnV0dG9ucykpIHJldHVybjtcbiAgICBjb25zdCBjdHJsSWRzID0gdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBpZiAoY29uZmlnLnBvaW50ZXJDYXB0dXJlKSB7XG4gICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB9XG4gICAgaWYgKGN0cmxJZHMgJiYgY3RybElkcy5zaXplID4gMSAmJiBzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuc2V0dXBQb2ludGVyKGV2ZW50KTtcbiAgICBzdGF0ZS5fcG9pbnRlcklkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBzdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHBvaW50ZXJWYWx1ZXMoZXZlbnQpKTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgaWYgKGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyAmJiBnZXRQb2ludGVyVHlwZShldmVudCkgIT09ICdtb3VzZScpIHtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0dXBTY3JvbGxQcmV2ZW50aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZWxheSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBEZWxheVRyaWdnZXIoZXZlbnQpO1xuICAgICAgaWYgKGNvbmZpZy50cmlnZ2VyQWxsRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBzdGFydFBvaW50ZXJEcmFnKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9hY3RpdmUgPSB0cnVlO1xuICAgIHN0YXRlLl9wcmV2ZW50U2Nyb2xsID0gdHJ1ZTtcbiAgICBzdGF0ZS5fZGVsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJJZCAhPT0gdW5kZWZpbmVkICYmIGlkICE9PSBzdGF0ZS5fcG9pbnRlcklkKSByZXR1cm47XG4gICAgY29uc3QgX3ZhbHVlcyA9IHBvaW50ZXJWYWx1ZXMoZXZlbnQpO1xuICAgIGlmIChkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgc3RhdGUuX2RlbHRhID0gW2V2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuX2RlbHRhID0gVi5zdWIoX3ZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoX3ZhbHVlcyk7XG4gICAgfVxuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgaWYgKHN0YXRlLl9kZWxheWVkICYmIHN0YXRlLmludGVudGlvbmFsKSB7XG4gICAgICB0aGlzLnRpbWVvdXRTdG9yZS5yZW1vdmUoJ2RyYWdEZWxheScpO1xuICAgICAgc3RhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnByZXZlbnRTY3JvbGxBeGlzICYmICFzdGF0ZS5fcHJldmVudFNjcm9sbCkge1xuICAgICAgaWYgKHN0YXRlLmF4aXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmF4aXMgPT09IGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyB8fCBjb25maWcucHJldmVudFNjcm9sbEF4aXMgPT09ICd4eScpIHtcbiAgICAgICAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXRTdG9yZS5yZW1vdmUoJ3N0YXJ0UG9pbnRlckRyYWcnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBwb2ludGVyVXAoZXZlbnQpIHtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jb25maWcucG9pbnRlckNhcHR1cmUgJiYgZXZlbnQudGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgO1xuICAgICAgICBldmVudC50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBpdCdzIGxpa2VseSB0aGF0IHlvdSdyZSB1c2luZyBhbiBvdXRkYXRlZCB2ZXJzaW9uIG9mIFxcYEByZWFjdC10aHJlZS9maWJlclxcYC4gXFxuXFxuUGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlIHx8ICFzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJJZCAhPT0gdW5kZWZpbmVkICYmIGlkICE9PSBzdGF0ZS5fcG9pbnRlcklkKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QWN0aXZlKCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICBjb25zdCBbZHgsIGR5XSA9IHN0YXRlLl9kaXN0YW5jZTtcbiAgICBzdGF0ZS50YXAgPSBkeCA8PSBjb25maWcudGFwc1RocmVzaG9sZCAmJiBkeSA8PSBjb25maWcudGFwc1RocmVzaG9sZDtcbiAgICBpZiAoc3RhdGUudGFwICYmIGNvbmZpZy5maWx0ZXJUYXBzKSB7XG4gICAgICBzdGF0ZS5fZm9yY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbX2R4LCBfZHldID0gc3RhdGUuX2RlbHRhO1xuICAgICAgY29uc3QgW19teCwgX215XSA9IHN0YXRlLl9tb3ZlbWVudDtcbiAgICAgIGNvbnN0IFtzdngsIHN2eV0gPSBjb25maWcuc3dpcGUudmVsb2NpdHk7XG4gICAgICBjb25zdCBbc3gsIHN5XSA9IGNvbmZpZy5zd2lwZS5kaXN0YW5jZTtcbiAgICAgIGNvbnN0IHNkdCA9IGNvbmZpZy5zd2lwZS5kdXJhdGlvbjtcbiAgICAgIGlmIChzdGF0ZS5lbGFwc2VkVGltZSA8IHNkdCkge1xuICAgICAgICBjb25zdCBfdnggPSBNYXRoLmFicyhfZHggLyBzdGF0ZS50aW1lRGVsdGEpO1xuICAgICAgICBjb25zdCBfdnkgPSBNYXRoLmFicyhfZHkgLyBzdGF0ZS50aW1lRGVsdGEpO1xuICAgICAgICBpZiAoX3Z4ID4gc3Z4ICYmIE1hdGguYWJzKF9teCkgPiBzeCkgc3RhdGUuc3dpcGVbMF0gPSBNYXRoLnNpZ24oX2R4KTtcbiAgICAgICAgaWYgKF92eSA+IHN2eSAmJiBNYXRoLmFicyhfbXkpID4gc3kpIHN0YXRlLnN3aXBlWzFdID0gTWF0aC5zaWduKF9keSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHBvaW50ZXJDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS50YXAgJiYgZXZlbnQuZGV0YWlsID4gMCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICBzZXR1cFBvaW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBkZXZpY2UgPSBjb25maWcuZGV2aWNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRldmljZSA9PT0gJ3BvaW50ZXInICYmIGNvbmZpZy5wcmV2ZW50U2Nyb2xsRGVsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSAndXYnIGluIGV2ZW50ID8gZXZlbnQuc291cmNlRXZlbnQuY3VycmVudFRhcmdldCA6IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICBpZiAoc3R5bGUudG91Y2hBY3Rpb24gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogVGhlIGRyYWcgdGFyZ2V0IGhhcyBpdHMgXFxgdG91Y2gtYWN0aW9uXFxgIHN0eWxlIHByb3BlcnR5IHNldCB0byBcXGBhdXRvXFxgLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhZGQgXFxgdG91Y2gtYWN0aW9uOiAnbm9uZSdcXGAgc28gdGhhdCB0aGUgZHJhZyBnZXN0dXJlIGJlaGF2ZXMgY29ycmVjdGx5IG9uIHRvdWNoLWVuYWJsZWQgZGV2aWNlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcmVhZCB0aGlzOiBodHRwczovL3VzZS1nZXN0dXJlLm5ldGxpZnkuYXBwL2RvY3MvZXh0cmFzLyN0b3VjaC1hY3Rpb24uXFxuXFxuVGhpcyBtZXNzYWdlIHdpbGwgb25seSBzaG93IGluIGRldmVsb3BtZW50IG1vZGUuIEl0IHdvbid0IGFwcGVhciBpbiBwcm9kdWN0aW9uLiBJZiB0aGlzIGlzIGludGVuZGVkLCB5b3UgY2FuIGlnbm9yZSBpdC5gLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnBvaW50ZXJMb2NrKSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5wb2ludGVyQ2FwdHVyZSkge1xuICAgICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csIGRldmljZSwgJ2NoYW5nZScsIHRoaXMucG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgZGV2aWNlLCAnZW5kJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgZGV2aWNlLCAnY2FuY2VsJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJDbGVhbigpIHtcbiAgICBpZiAodGhpcy5jb25maWcucG9pbnRlckxvY2sgJiYgZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID09PSB0aGlzLnN0YXRlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgfVxuICBwcmV2ZW50U2Nyb2xsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX3ByZXZlbnRTY3JvbGwgJiYgZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBTY3JvbGxQcmV2ZW50aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5zdGF0ZS5fcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICAgIHBlcnNpc3RFdmVudChldmVudCk7XG4gICAgY29uc3QgcmVtb3ZlID0gdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csICd0b3VjaCcsICdjaGFuZ2UnLCB0aGlzLnByZXZlbnRTY3JvbGwuYmluZCh0aGlzKSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgJ3RvdWNoJywgJ2VuZCcsIHJlbW92ZSk7XG4gICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csICd0b3VjaCcsICdjYW5jZWwnLCByZW1vdmUpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnc3RhcnRQb2ludGVyRHJhZycsIHRoaXMuc3RhcnRQb2ludGVyRHJhZy5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy5wcmV2ZW50U2Nyb2xsRGVsYXksIGV2ZW50KTtcbiAgfVxuICBzZXR1cERlbGF5VHJpZ2dlcihldmVudCkge1xuICAgIHRoaXMuc3RhdGUuX2RlbGF5ZWQgPSB0cnVlO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnZHJhZ0RlbGF5JywgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5fc3RlcCA9IFswLCAwXTtcbiAgICAgIHRoaXMuc3RhcnRQb2ludGVyRHJhZyhldmVudCk7XG4gICAgfSwgdGhpcy5jb25maWcuZGVsYXkpO1xuICB9XG4gIGtleURvd24oZXZlbnQpIHtcbiAgICBjb25zdCBkZWx0YUZuID0gS0VZU19ERUxUQV9NQVBbZXZlbnQua2V5XTtcbiAgICBpZiAoZGVsdGFGbikge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgZmFjdG9yID0gZXZlbnQuc2hpZnRLZXkgPyAxMCA6IGV2ZW50LmFsdEtleSA/IDAuMSA6IDE7XG4gICAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgIHN0YXRlLl9kZWx0YSA9IGRlbHRhRm4odGhpcy5jb25maWcua2V5Ym9hcmREaXNwbGFjZW1lbnQsIGZhY3Rvcik7XG4gICAgICBzdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSB0cnVlO1xuICAgICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfVxuICB9XG4gIGtleVVwKGV2ZW50KSB7XG4gICAgaWYgKCEoZXZlbnQua2V5IGluIEtFWVNfREVMVEFfTUFQKSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmUoKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5jb25maWcuZGV2aWNlO1xuICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdzdGFydCcsIHRoaXMucG9pbnRlckRvd24uYmluZCh0aGlzKSk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnBvaW50ZXJDYXB0dXJlKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnY2hhbmdlJywgdGhpcy5wb2ludGVyTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdlbmQnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjYW5jZWwnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbignbG9zdFBvaW50ZXJDYXB0dXJlJywgJycsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcua2V5cykge1xuICAgICAgYmluZEZ1bmN0aW9uKCdrZXknLCAnZG93bicsIHRoaXMua2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbigna2V5JywgJ3VwJywgdGhpcy5rZXlVcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmZpbHRlclRhcHMpIHtcbiAgICAgIGJpbmRGdW5jdGlvbignY2xpY2snLCAnJywgdGhpcy5wb2ludGVyQ2xpY2suYmluZCh0aGlzKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0RXZlbnQoZXZlbnQpIHtcbiAgJ3BlcnNpc3QnIGluIGV2ZW50ICYmIHR5cGVvZiBldmVudC5wZXJzaXN0ID09PSAnZnVuY3Rpb24nICYmIGV2ZW50LnBlcnNpc3QoKTtcbn1cblxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuZnVuY3Rpb24gc3VwcG9ydHNUb3VjaEV2ZW50cygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG59XG5mdW5jdGlvbiBpc1RvdWNoU2NyZWVuKCkge1xuICByZXR1cm4gc3VwcG9ydHNUb3VjaEV2ZW50cygpIHx8IGlzQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUG9pbnRlckV2ZW50cygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnb25wb2ludGVyZG93bicgaW4gd2luZG93O1xufVxuZnVuY3Rpb24gc3VwcG9ydHNQb2ludGVyTG9jaygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnZXhpdFBvaW50ZXJMb2NrJyBpbiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0dlc3R1cmVFdmVudHMoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICdjb25zdHJ1Y3RvcicgaW4gR2VzdHVyZUV2ZW50O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBTVVBQT1JUID0ge1xuICBpc0Jyb3dzZXIsXG4gIGdlc3R1cmU6IHN1cHBvcnRzR2VzdHVyZUV2ZW50cygpLFxuICB0b3VjaDogc3VwcG9ydHNUb3VjaEV2ZW50cygpLFxuICB0b3VjaHNjcmVlbjogaXNUb3VjaFNjcmVlbigpLFxuICBwb2ludGVyOiBzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSxcbiAgcG9pbnRlckxvY2s6IHN1cHBvcnRzUG9pbnRlckxvY2soKVxufTtcblxuY29uc3QgREVGQVVMVF9QUkVWRU5UX1NDUk9MTF9ERUxBWSA9IDI1MDtcbmNvbnN0IERFRkFVTFRfRFJBR19ERUxBWSA9IDE4MDtcbmNvbnN0IERFRkFVTFRfU1dJUEVfVkVMT0NJVFkgPSAwLjU7XG5jb25zdCBERUZBVUxUX1NXSVBFX0RJU1RBTkNFID0gNTA7XG5jb25zdCBERUZBVUxUX1NXSVBFX0RVUkFUSU9OID0gMjUwO1xuY29uc3QgREVGQVVMVF9LRVlCT0FSRF9ESVNQTEFDRU1FTlQgPSAxMDtcbmNvbnN0IERFRkFVTFRfRFJBR19BWElTX1RIUkVTSE9MRCA9IHtcbiAgbW91c2U6IDAsXG4gIHRvdWNoOiAwLFxuICBwZW46IDhcbn07XG5jb25zdCBkcmFnQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlciksIHt9LCB7XG4gIGRldmljZShfdiwgX2ssIHtcbiAgICBwb2ludGVyOiB7XG4gICAgICB0b3VjaCA9IGZhbHNlLFxuICAgICAgbG9jayA9IGZhbHNlLFxuICAgICAgbW91c2UgPSBmYWxzZVxuICAgIH0gPSB7fVxuICB9KSB7XG4gICAgdGhpcy5wb2ludGVyTG9jayA9IGxvY2sgJiYgU1VQUE9SVC5wb2ludGVyTG9jaztcbiAgICBpZiAoU1VQUE9SVC50b3VjaCAmJiB0b3VjaCkgcmV0dXJuICd0b3VjaCc7XG4gICAgaWYgKHRoaXMucG9pbnRlckxvY2spIHJldHVybiAnbW91c2UnO1xuICAgIGlmIChTVVBQT1JULnBvaW50ZXIgJiYgIW1vdXNlKSByZXR1cm4gJ3BvaW50ZXInO1xuICAgIGlmIChTVVBQT1JULnRvdWNoKSByZXR1cm4gJ3RvdWNoJztcbiAgICByZXR1cm4gJ21vdXNlJztcbiAgfSxcbiAgcHJldmVudFNjcm9sbEF4aXModmFsdWUsIF9rLCB7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KSB7XG4gICAgdGhpcy5wcmV2ZW50U2Nyb2xsRGVsYXkgPSB0eXBlb2YgcHJldmVudFNjcm9sbCA9PT0gJ251bWJlcicgPyBwcmV2ZW50U2Nyb2xsIDogcHJldmVudFNjcm9sbCB8fCBwcmV2ZW50U2Nyb2xsID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPyBERUZBVUxUX1BSRVZFTlRfU0NST0xMX0RFTEFZIDogdW5kZWZpbmVkO1xuICAgIGlmICghU1VQUE9SVC50b3VjaHNjcmVlbiB8fCBwcmV2ZW50U2Nyb2xsID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IHByZXZlbnRTY3JvbGwgIT09IHVuZGVmaW5lZCA/ICd5JyA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgcG9pbnRlckNhcHR1cmUoX3YsIF9rLCB7XG4gICAgcG9pbnRlcjoge1xuICAgICAgY2FwdHVyZSA9IHRydWUsXG4gICAgICBidXR0b25zID0gMSxcbiAgICAgIGtleXMgPSB0cnVlXG4gICAgfSA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLnBvaW50ZXJCdXR0b25zID0gYnV0dG9ucztcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHJldHVybiAhdGhpcy5wb2ludGVyTG9jayAmJiB0aGlzLmRldmljZSA9PT0gJ3BvaW50ZXInICYmIGNhcHR1cmU7XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSwgX2ssIHtcbiAgICBmaWx0ZXJUYXBzID0gZmFsc2UsXG4gICAgdGFwc1RocmVzaG9sZCA9IDMsXG4gICAgYXhpcyA9IHVuZGVmaW5lZFxuICB9KSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gVi50b1ZlY3Rvcih2YWx1ZSwgZmlsdGVyVGFwcyA/IHRhcHNUaHJlc2hvbGQgOiBheGlzID8gMSA6IDApO1xuICAgIHRoaXMuZmlsdGVyVGFwcyA9IGZpbHRlclRhcHM7XG4gICAgdGhpcy50YXBzVGhyZXNob2xkID0gdGFwc1RocmVzaG9sZDtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xuICB9LFxuICBzd2lwZSh7XG4gICAgdmVsb2NpdHkgPSBERUZBVUxUX1NXSVBFX1ZFTE9DSVRZLFxuICAgIGRpc3RhbmNlID0gREVGQVVMVF9TV0lQRV9ESVNUQU5DRSxcbiAgICBkdXJhdGlvbiA9IERFRkFVTFRfU1dJUEVfRFVSQVRJT05cbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlbG9jaXR5OiB0aGlzLnRyYW5zZm9ybShWLnRvVmVjdG9yKHZlbG9jaXR5KSksXG4gICAgICBkaXN0YW5jZTogdGhpcy50cmFuc2Zvcm0oVi50b1ZlY3RvcihkaXN0YW5jZSkpLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9LFxuICBkZWxheSh2YWx1ZSA9IDApIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiBERUZBVUxUX0RSQUdfREVMQVk7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIGF4aXNUaHJlc2hvbGQodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSByZXR1cm4gREVGQVVMVF9EUkFHX0FYSVNfVEhSRVNIT0xEO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9EUkFHX0FYSVNfVEhSRVNIT0xEKSwgdmFsdWUpO1xuICB9LFxuICBrZXlib2FyZERpc3BsYWNlbWVudCh2YWx1ZSA9IERFRkFVTFRfS0VZQk9BUkRfRElTUExBQ0VNRU5UKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBPYmplY3QuYXNzaWduKGRyYWdDb25maWdSZXNvbHZlciwge1xuICAgIHVzZVRvdWNoKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHVzZVRvdWNoXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHBvaW50ZXIudG91Y2hcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHBvaW50ZXI6IHsgdG91Y2g6IHRydWUgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIGV4cGVyaW1lbnRhbF9wcmV2ZW50V2luZG93U2Nyb2xsWSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBleHBlcmltZW50YWxfcHJldmVudFdpbmRvd1Njcm9sbFlcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgcHJldmVudFNjcm9sbFxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBzd2lwZVZlbG9jaXR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHN3aXBlVmVsb2NpdHlcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgc3dpcGUudmVsb2NpdHlcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHN3aXBlOiB7IHZlbG9jaXR5OiAwLjUgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIHN3aXBlRGlzdGFuY2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgc3dpcGVEaXN0YW5jZVxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBzd2lwZS5kaXN0YW5jZVxcYC4gVXNlIGl0IGFzIGluIFxcYHsgc3dpcGU6IHsgZGlzdGFuY2U6IDUwIH0gfVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBzd2lwZUR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHN3aXBlRHVyYXRpb25cXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgc3dpcGUuZHVyYXRpb25cXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHN3aXBlOiB7IGR1cmF0aW9uOiAyNTAgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGFtcFN0YXRlSW50ZXJuYWxNb3ZlbWVudFRvQm91bmRzKHN0YXRlKSB7XG4gIGNvbnN0IFtveCwgb3ldID0gc3RhdGUub3ZlcmZsb3c7XG4gIGNvbnN0IFtkeCwgZHldID0gc3RhdGUuX2RlbHRhO1xuICBjb25zdCBbZGlyeCwgZGlyeV0gPSBzdGF0ZS5fZGlyZWN0aW9uO1xuICBpZiAob3ggPCAwICYmIGR4ID4gMCAmJiBkaXJ4IDwgMCB8fCBveCA+IDAgJiYgZHggPCAwICYmIGRpcnggPiAwKSB7XG4gICAgc3RhdGUuX21vdmVtZW50WzBdID0gc3RhdGUuX21vdmVtZW50Qm91bmRbMF07XG4gIH1cbiAgaWYgKG95IDwgMCAmJiBkeSA+IDAgJiYgZGlyeSA8IDAgfHwgb3kgPiAwICYmIGR5IDwgMCAmJiBkaXJ5ID4gMCkge1xuICAgIHN0YXRlLl9tb3ZlbWVudFsxXSA9IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdO1xuICB9XG59XG5cbmNvbnN0IFNDQUxFX0FOR0xFX1JBVElPX0lOVEVOVF9ERUcgPSAzMDtcbmNvbnN0IFBJTkNIX1dIRUVMX1JBVElPID0gMTAwO1xuY2xhc3MgUGluY2hFbmdpbmUgZXh0ZW5kcyBFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdwaW5jaGluZycpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaWFzS2V5XCIsICdkYScpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBbMSwgMF07XG4gICAgdGhpcy5zdGF0ZS5sYXN0T2Zmc2V0ID0gWzEsIDBdO1xuICAgIHRoaXMuc3RhdGUuX3BvaW50ZXJFdmVudHMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX3RvdWNoSWRzID0gW107XG4gICAgc3RhdGUuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5jYW5jZWwgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHN0YXRlLnR1cm5zID0gMDtcbiAgfVxuICBjb21wdXRlT2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBtb3ZlbWVudCxcbiAgICAgIGxhc3RPZmZzZXRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBWLmFkZChtb3ZlbWVudCwgbGFzdE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gWygxICsgbW92ZW1lbnRbMF0pICogbGFzdE9mZnNldFswXSwgbW92ZW1lbnRbMV0gKyBsYXN0T2Zmc2V0WzFdXTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZU1vdmVtZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldCxcbiAgICAgIGxhc3RPZmZzZXRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlLm1vdmVtZW50ID0gW29mZnNldFswXSAvIGxhc3RPZmZzZXRbMF0sIG9mZnNldFsxXSAtIGxhc3RPZmZzZXRbMV1dO1xuICB9XG4gIGF4aXNJbnRlbnQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IFtfbTAsIF9tMV0gPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgaWYgKCFzdGF0ZS5heGlzKSB7XG4gICAgICBjb25zdCBheGlzTW92ZW1lbnREaWZmZXJlbmNlID0gTWF0aC5hYnMoX20wKSAqIFNDQUxFX0FOR0xFX1JBVElPX0lOVEVOVF9ERUcgLSBNYXRoLmFicyhfbTEpO1xuICAgICAgaWYgKGF4aXNNb3ZlbWVudERpZmZlcmVuY2UgPCAwKSBzdGF0ZS5heGlzID0gJ2FuZ2xlJztlbHNlIGlmIChheGlzTW92ZW1lbnREaWZmZXJlbmNlID4gMCkgc3RhdGUuYXhpcyA9ICdzY2FsZSc7XG4gICAgfVxuICB9XG4gIHJlc3RyaWN0VG9BeGlzKHYpIHtcbiAgICBpZiAodGhpcy5jb25maWcubG9ja0RpcmVjdGlvbikge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYXhpcyA9PT0gJ3NjYWxlJykgdlsxXSA9IDA7ZWxzZSBpZiAodGhpcy5zdGF0ZS5heGlzID09PSAnYW5nbGUnKSB2WzBdID0gMDtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY2FuY2VsZWQpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0YXRlLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgdG91Y2hTdGFydChldmVudCkge1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGN0cmxUb3VjaElkcyA9IHRoaXMuY3RybC50b3VjaElkcztcbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgaWYgKHN0YXRlLl90b3VjaElkcy5ldmVyeShpZCA9PiBjdHJsVG91Y2hJZHMuaGFzKGlkKSkpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN0cmxUb3VjaElkcy5zaXplIDwgMikgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHN0YXRlLl90b3VjaElkcyA9IEFycmF5LmZyb20oY3RybFRvdWNoSWRzKS5zbGljZSgwLCAyKTtcbiAgICBjb25zdCBwYXlsb2FkID0gdG91Y2hEaXN0YW5jZUFuZ2xlKGV2ZW50LCBzdGF0ZS5fdG91Y2hJZHMpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hTdGFydChldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcG9pbnRlclN0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbnMgIT0gbnVsbCAmJiBldmVudC5idXR0b25zICUgMiAhPT0gMSkgcmV0dXJuO1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IF9wb2ludGVyRXZlbnRzID0gc3RhdGUuX3BvaW50ZXJFdmVudHM7XG4gICAgY29uc3QgY3RybFBvaW50ZXJJZHMgPSB0aGlzLmN0cmwucG9pbnRlcklkcztcbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgaWYgKEFycmF5LmZyb20oX3BvaW50ZXJFdmVudHMua2V5cygpKS5ldmVyeShpZCA9PiBjdHJsUG9pbnRlcklkcy5oYXMoaWQpKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoX3BvaW50ZXJFdmVudHMuc2l6ZSA8IDIpIHtcbiAgICAgIF9wb2ludGVyRXZlbnRzLnNldChldmVudC5wb2ludGVySWQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLl9wb2ludGVyRXZlbnRzLnNpemUgPCAyKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGRpc3RhbmNlQW5nbGUoLi4uQXJyYXkuZnJvbShfcG9pbnRlckV2ZW50cy52YWx1ZXMoKSkpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hTdGFydChldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcGluY2hTdGFydChldmVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBwYXlsb2FkLm9yaWdpbjtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW3BheWxvYWQuZGlzdGFuY2UsIHBheWxvYWQuYW5nbGVdKTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB0b3VjaE1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSB0b3VjaERpc3RhbmNlQW5nbGUoZXZlbnQsIHRoaXMuc3RhdGUuX3RvdWNoSWRzKTtcbiAgICBpZiAoIXBheWxvYWQpIHJldHVybjtcbiAgICB0aGlzLnBpbmNoTW92ZShldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBfcG9pbnRlckV2ZW50cyA9IHRoaXMuc3RhdGUuX3BvaW50ZXJFdmVudHM7XG4gICAgaWYgKF9wb2ludGVyRXZlbnRzLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBfcG9pbnRlckV2ZW50cy5zZXQoZXZlbnQucG9pbnRlcklkLCBldmVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgcGF5bG9hZCA9IGRpc3RhbmNlQW5nbGUoLi4uQXJyYXkuZnJvbShfcG9pbnRlckV2ZW50cy52YWx1ZXMoKSkpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hNb3ZlKGV2ZW50LCBwYXlsb2FkKTtcbiAgfVxuICBwaW5jaE1vdmUoZXZlbnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgcHJldl9hID0gc3RhdGUuX3ZhbHVlc1sxXTtcbiAgICBjb25zdCBkZWx0YV9hID0gcGF5bG9hZC5hbmdsZSAtIHByZXZfYTtcbiAgICBsZXQgZGVsdGFfdHVybnMgPSAwO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YV9hKSA+IDI3MCkgZGVsdGFfdHVybnMgKz0gTWF0aC5zaWduKGRlbHRhX2EpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbcGF5bG9hZC5kaXN0YW5jZSwgcGF5bG9hZC5hbmdsZSAtIDM2MCAqIGRlbHRhX3R1cm5zXSk7XG4gICAgc3RhdGUub3JpZ2luID0gcGF5bG9hZC5vcmlnaW47XG4gICAgc3RhdGUudHVybnMgPSBkZWx0YV90dXJucztcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBbc3RhdGUuX3ZhbHVlc1swXSAvIHN0YXRlLl9pbml0aWFsWzBdIC0gMSwgc3RhdGUuX3ZhbHVlc1sxXSAtIHN0YXRlLl9pbml0aWFsWzFdXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHRvdWNoRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnN0YXRlLl90b3VjaElkcy5zb21lKGlkID0+ICF0aGlzLmN0cmwudG91Y2hJZHMuaGFzKGlkKSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBwb2ludGVyRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50LnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIGlmIChzdGF0ZS5fcG9pbnRlckV2ZW50cy5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgc3RhdGUuX3BvaW50ZXJFdmVudHMuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5fcG9pbnRlckV2ZW50cy5zaXplIDwgMikge1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBnZXN0dXJlU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW2V2ZW50LnNjYWxlLCBldmVudC5yb3RhdGlvbl0pO1xuICAgIHN0YXRlLm9yaWdpbiA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGdlc3R1cmVNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKFtldmVudC5zY2FsZSwgZXZlbnQucm90YXRpb25dKTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV07XG4gICAgY29uc3QgX3ByZXZpb3VzTW92ZW1lbnQgPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgc3RhdGUuX21vdmVtZW50ID0gW2V2ZW50LnNjYWxlIC0gMSwgZXZlbnQucm90YXRpb25dO1xuICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKHN0YXRlLl9tb3ZlbWVudCwgX3ByZXZpb3VzTW92ZW1lbnQpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgZ2VzdHVyZUVuZChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB3aGVlbChldmVudCkge1xuICAgIGNvbnN0IG1vZGlmaWVyS2V5ID0gdGhpcy5jb25maWcubW9kaWZpZXJLZXk7XG4gICAgaWYgKG1vZGlmaWVyS2V5ICYmIChBcnJheS5pc0FycmF5KG1vZGlmaWVyS2V5KSA/ICFtb2RpZmllcktleS5maW5kKGsgPT4gZXZlbnRba10pIDogIWV2ZW50W21vZGlmaWVyS2V5XSkpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy53aGVlbFN0YXJ0KGV2ZW50KTtlbHNlIHRoaXMud2hlZWxDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnd2hlZWxFbmQnLCB0aGlzLndoZWVsRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIHdoZWVsU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLndoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgfVxuICB3aGVlbENoYW5nZShldmVudCkge1xuICAgIGNvbnN0IGlzUjNmID0gKCd1dicgaW4gZXZlbnQpO1xuICAgIGlmICghaXNSM2YpIHtcbiAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogVG8gcHJvcGVybHkgc3VwcG9ydCB6b29tIG9uIHRyYWNrcGFkcywgdHJ5IHVzaW5nIHRoZSBcXGB0YXJnZXRcXGAgb3B0aW9uLlxcblxcblRoaXMgbWVzc2FnZSB3aWxsIG9ubHkgYXBwZWFyIGluIGRldmVsb3BtZW50IG1vZGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBbLXdoZWVsVmFsdWVzKGV2ZW50KVsxXSAvIFBJTkNIX1dIRUVMX1JBVElPICogc3RhdGUub2Zmc2V0WzBdLCAwXTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICBjbGFtcFN0YXRlSW50ZXJuYWxNb3ZlbWVudFRvQm91bmRzKHN0YXRlKTtcbiAgICB0aGlzLnN0YXRlLm9yaWdpbiA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHdoZWVsRW5kKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmNvbmZpZy5kZXZpY2U7XG4gICAgaWYgKCEhZGV2aWNlKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnc3RhcnQnLCB0aGlzW2RldmljZSArICdTdGFydCddLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2NoYW5nZScsIHRoaXNbZGV2aWNlICsgJ01vdmUnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdlbmQnLCB0aGlzW2RldmljZSArICdFbmQnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjYW5jZWwnLCB0aGlzW2RldmljZSArICdFbmQnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbignbG9zdFBvaW50ZXJDYXB0dXJlJywgJycsIHRoaXNbZGV2aWNlICsgJ0VuZCddLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucGluY2hPbldoZWVsKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oJ3doZWVsJywgJycsIHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHBpbmNoQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBkZXZpY2UoX3YsIF9rLCB7XG4gICAgc2hhcmVkLFxuICAgIHBvaW50ZXI6IHtcbiAgICAgIHRvdWNoID0gZmFsc2VcbiAgICB9ID0ge31cbiAgfSkge1xuICAgIGNvbnN0IHNoYXJlZENvbmZpZyA9IHNoYXJlZDtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLnRhcmdldCAmJiAhU1VQUE9SVC50b3VjaCAmJiBTVVBQT1JULmdlc3R1cmUpIHJldHVybiAnZ2VzdHVyZSc7XG4gICAgaWYgKFNVUFBPUlQudG91Y2ggJiYgdG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIGlmIChTVVBQT1JULnRvdWNoc2NyZWVuKSB7XG4gICAgICBpZiAoU1VQUE9SVC5wb2ludGVyKSByZXR1cm4gJ3BvaW50ZXInO1xuICAgICAgaWYgKFNVUFBPUlQudG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIH1cbiAgfSxcbiAgYm91bmRzKF92LCBfaywge1xuICAgIHNjYWxlQm91bmRzID0ge30sXG4gICAgYW5nbGVCb3VuZHMgPSB7fVxuICB9KSB7XG4gICAgY29uc3QgX3NjYWxlQm91bmRzID0gc3RhdGUgPT4ge1xuICAgICAgY29uc3QgRCA9IGFzc2lnbkRlZmF1bHQoY2FsbChzY2FsZUJvdW5kcywgc3RhdGUpLCB7XG4gICAgICAgIG1pbjogLUluZmluaXR5LFxuICAgICAgICBtYXg6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbRC5taW4sIEQubWF4XTtcbiAgICB9O1xuICAgIGNvbnN0IF9hbmdsZUJvdW5kcyA9IHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IEEgPSBhc3NpZ25EZWZhdWx0KGNhbGwoYW5nbGVCb3VuZHMsIHN0YXRlKSwge1xuICAgICAgICBtaW46IC1JbmZpbml0eSxcbiAgICAgICAgbWF4OiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW0EubWluLCBBLm1heF07XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHNjYWxlQm91bmRzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhbmdsZUJvdW5kcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFtfc2NhbGVCb3VuZHMoKSwgX2FuZ2xlQm91bmRzKCldO1xuICAgIHJldHVybiBzdGF0ZSA9PiBbX3NjYWxlQm91bmRzKHN0YXRlKSwgX2FuZ2xlQm91bmRzKHN0YXRlKV07XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSwgX2ssIGNvbmZpZykge1xuICAgIHRoaXMubG9ja0RpcmVjdGlvbiA9IGNvbmZpZy5heGlzID09PSAnbG9jayc7XG4gICAgY29uc3QgdGhyZXNob2xkID0gVi50b1ZlY3Rvcih2YWx1ZSwgdGhpcy5sb2NrRGlyZWN0aW9uID8gWzAuMSwgM10gOiAwKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xuICB9LFxuICBtb2RpZmllcktleSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ2N0cmxLZXknO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgcGluY2hPbldoZWVsKHZhbHVlID0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbmNsYXNzIE1vdmVFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ21vdmluZycpO1xuICB9XG4gIG1vdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubW91c2VPbmx5ICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSAnbW91c2UnKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHRoaXMubW92ZVN0YXJ0KGV2ZW50KTtlbHNlIHRoaXMubW92ZUNoYW5nZShldmVudCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCdtb3ZlRW5kJywgdGhpcy5tb3ZlRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIG1vdmVTdGFydChldmVudCkge1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhwb2ludGVyVmFsdWVzKGV2ZW50KSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgbW92ZUNoYW5nZShldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgdmFsdWVzID0gcG9pbnRlclZhbHVlcyhldmVudCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKHZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHZhbHVlcyk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBtb3ZlRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2NoYW5nZScsIHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICBiaW5kRnVuY3Rpb24oJ3BvaW50ZXInLCAnbGVhdmUnLCB0aGlzLm1vdmVFbmQuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3QgbW92ZUNvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBtb3VzZU9ubHk6ICh2YWx1ZSA9IHRydWUpID0+IHZhbHVlXG59KTtcblxuY2xhc3MgU2Nyb2xsRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdzY3JvbGxpbmcnKTtcbiAgfVxuICBzY3JvbGwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5zY3JvbGxDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnc2Nyb2xsRW5kJywgdGhpcy5zY3JvbGxFbmQuYmluZCh0aGlzKSk7XG4gIH1cbiAgc2Nyb2xsQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHNjcm9sbFZhbHVlcyhldmVudCk7XG4gICAgc3RhdGUuX2RlbHRhID0gVi5zdWIodmFsdWVzLCBzdGF0ZS5fdmFsdWVzKTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXModmFsdWVzKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHNjcm9sbEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCdzY3JvbGwnLCAnJywgdGhpcy5zY3JvbGwuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3Qgc2Nyb2xsQ29uZmlnUmVzb2x2ZXIgPSBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyO1xuXG5jbGFzcyBXaGVlbEVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnd2hlZWxpbmcnKTtcbiAgfVxuICB3aGVlbChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLndoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ3doZWVsRW5kJywgdGhpcy53aGVlbEVuZC5iaW5kKHRoaXMpKTtcbiAgfVxuICB3aGVlbENoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fZGVsdGEgPSB3aGVlbFZhbHVlcyhldmVudCk7XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgY2xhbXBTdGF0ZUludGVybmFsTW92ZW1lbnRUb0JvdW5kcyhzdGF0ZSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB3aGVlbEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCd3aGVlbCcsICcnLCB0aGlzLndoZWVsLmJpbmQodGhpcykpO1xuICB9XG59XG5cbmNvbnN0IHdoZWVsQ29uZmlnUmVzb2x2ZXIgPSBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyO1xuXG5jbGFzcyBIb3ZlckVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnaG92ZXJpbmcnKTtcbiAgfVxuICBlbnRlcihldmVudCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZU9ubHkgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICdtb3VzZScpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMocG9pbnRlclZhbHVlcyhldmVudCkpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgbGVhdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubW91c2VPbmx5ICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSAnbW91c2UnKSByZXR1cm47XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBwb2ludGVyVmFsdWVzKGV2ZW50KTtcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBzdGF0ZS5fZGVsdGEgPSBWLnN1Yih2YWx1ZXMsIHN0YXRlLl92YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyh2YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgc3RhdGUuZGVsdGEgPSBzdGF0ZS5tb3ZlbWVudDtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGJpbmRGdW5jdGlvbigncG9pbnRlcicsICdlbnRlcicsIHRoaXMuZW50ZXIuYmluZCh0aGlzKSk7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2xlYXZlJywgdGhpcy5sZWF2ZS5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5jb25zdCBob3ZlckNvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBtb3VzZU9ubHk6ICh2YWx1ZSA9IHRydWUpID0+IHZhbHVlXG59KTtcblxuY29uc3QgRW5naW5lTWFwID0gbmV3IE1hcCgpO1xuY29uc3QgQ29uZmlnUmVzb2x2ZXJNYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbihhY3Rpb24pIHtcbiAgRW5naW5lTWFwLnNldChhY3Rpb24ua2V5LCBhY3Rpb24uZW5naW5lKTtcbiAgQ29uZmlnUmVzb2x2ZXJNYXAuc2V0KGFjdGlvbi5rZXksIGFjdGlvbi5yZXNvbHZlcik7XG59XG5jb25zdCBkcmFnQWN0aW9uID0ge1xuICBrZXk6ICdkcmFnJyxcbiAgZW5naW5lOiBEcmFnRW5naW5lLFxuICByZXNvbHZlcjogZHJhZ0NvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3QgaG92ZXJBY3Rpb24gPSB7XG4gIGtleTogJ2hvdmVyJyxcbiAgZW5naW5lOiBIb3ZlckVuZ2luZSxcbiAgcmVzb2x2ZXI6IGhvdmVyQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBtb3ZlQWN0aW9uID0ge1xuICBrZXk6ICdtb3ZlJyxcbiAgZW5naW5lOiBNb3ZlRW5naW5lLFxuICByZXNvbHZlcjogbW92ZUNvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3QgcGluY2hBY3Rpb24gPSB7XG4gIGtleTogJ3BpbmNoJyxcbiAgZW5naW5lOiBQaW5jaEVuZ2luZSxcbiAgcmVzb2x2ZXI6IHBpbmNoQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBzY3JvbGxBY3Rpb24gPSB7XG4gIGtleTogJ3Njcm9sbCcsXG4gIGVuZ2luZTogU2Nyb2xsRW5naW5lLFxuICByZXNvbHZlcjogc2Nyb2xsQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCB3aGVlbEFjdGlvbiA9IHtcbiAga2V5OiAnd2hlZWwnLFxuICBlbmdpbmU6IFdoZWVsRW5naW5lLFxuICByZXNvbHZlcjogd2hlZWxDb25maWdSZXNvbHZlclxufTtcblxuZXhwb3J0IHsgQ29uZmlnUmVzb2x2ZXJNYXAgYXMgQywgRW5naW5lTWFwIGFzIEUsIFNVUFBPUlQgYXMgUywgX29iamVjdFNwcmVhZDIgYXMgXywgX2RlZmluZVByb3BlcnR5IGFzIGEsIHRvdWNoSWRzIGFzIGIsIGNoYWluIGFzIGMsIHRvSGFuZGxlclByb3AgYXMgZCwgZHJhZ0FjdGlvbiBhcyBlLCBwaW5jaEFjdGlvbiBhcyBmLCBob3ZlckFjdGlvbiBhcyBoLCBpc1RvdWNoIGFzIGksIG1vdmVBY3Rpb24gYXMgbSwgcGFyc2VQcm9wIGFzIHAsIHJlZ2lzdGVyQWN0aW9uIGFzIHIsIHNjcm9sbEFjdGlvbiBhcyBzLCB0b0RvbUV2ZW50VHlwZSBhcyB0LCB3aGVlbEFjdGlvbiBhcyB3IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ V),\n/* harmony export */   c: () => (/* binding */ computeRubberband),\n/* harmony export */   r: () => (/* binding */ rubberbandIfOutOfBounds)\n/* harmony export */ });\nfunction clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGFya3Jvb20uZW5naW5lZXJpbmcvc2F0dXMvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanM/NTc1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2LCBtYXgpKTtcbn1cbmNvbnN0IFYgPSB7XG4gIHRvVmVjdG9yKHYsIGZhbGxiYWNrKSB7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IGZhbGxiYWNrO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2LCB2XTtcbiAgfSxcbiAgYWRkKHYxLCB2Mikge1xuICAgIHJldHVybiBbdjFbMF0gKyB2MlswXSwgdjFbMV0gKyB2MlsxXV07XG4gIH0sXG4gIHN1Yih2MSwgdjIpIHtcbiAgICByZXR1cm4gW3YxWzBdIC0gdjJbMF0sIHYxWzFdIC0gdjJbMV1dO1xuICB9LFxuICBhZGRUbyh2MSwgdjIpIHtcbiAgICB2MVswXSArPSB2MlswXTtcbiAgICB2MVsxXSArPSB2MlsxXTtcbiAgfSxcbiAgc3ViVG8odjEsIHYyKSB7XG4gICAgdjFbMF0gLT0gdjJbMF07XG4gICAgdjFbMV0gLT0gdjJbMV07XG4gIH1cbn07XG5mdW5jdGlvbiBydWJiZXJiYW5kKGRpc3RhbmNlLCBkaW1lbnNpb24sIGNvbnN0YW50KSB7XG4gIGlmIChkaW1lbnNpb24gPT09IDAgfHwgTWF0aC5hYnMoZGltZW5zaW9uKSA9PT0gSW5maW5pdHkpIHJldHVybiBNYXRoLnBvdyhkaXN0YW5jZSwgY29uc3RhbnQgKiA1KTtcbiAgcmV0dXJuIGRpc3RhbmNlICogZGltZW5zaW9uICogY29uc3RhbnQgLyAoZGltZW5zaW9uICsgY29uc3RhbnQgKiBkaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhwb3NpdGlvbiwgbWluLCBtYXgsIGNvbnN0YW50ID0gMC4xNSkge1xuICBpZiAoY29uc3RhbnQgPT09IDApIHJldHVybiBjbGFtcChwb3NpdGlvbiwgbWluLCBtYXgpO1xuICBpZiAocG9zaXRpb24gPCBtaW4pIHJldHVybiAtcnViYmVyYmFuZChtaW4gLSBwb3NpdGlvbiwgbWF4IC0gbWluLCBjb25zdGFudCkgKyBtaW47XG4gIGlmIChwb3NpdGlvbiA+IG1heCkgcmV0dXJuICtydWJiZXJiYW5kKHBvc2l0aW9uIC0gbWF4LCBtYXggLSBtaW4sIGNvbnN0YW50KSArIG1heDtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJ1YmJlcmJhbmQoYm91bmRzLCBbVngsIFZ5XSwgW1J4LCBSeV0pIHtcbiAgY29uc3QgW1tYMCwgWDFdLCBbWTAsIFkxXV0gPSBib3VuZHM7XG4gIHJldHVybiBbcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMoVngsIFgwLCBYMSwgUngpLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhWeSwgWTAsIFkxLCBSeSldO1xufVxuXG5leHBvcnQgeyBWLCBjb21wdXRlUnViYmVyYmFuZCBhcyBjLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyBhcyByIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js":
/*!******************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   parseMergedHandlers: () => (/* binding */ parseMergedHandlers)\n/* harmony export */ });\n/* harmony import */ var _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions-fe213e88.esm.js */ \"(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js\");\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n    return undefined;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.S.isBrowser ? window : undefined) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (true) {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {}\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig,\n    {\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(gestureKey);\n    _config[gestureKey] = resolveWith((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(key);\n      if (resolver) {\n        _config[key] = resolveWith((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (true) {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl, gestureKey) {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_listeners\", new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach(remove => remove());\n    this._listeners.clear();\n  }\n}\n\nclass TimeoutStore {\n  constructor() {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_timeouts\", new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout) window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n}\n\nclass Controller {\n  constructor(handlers) {\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestures\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_targetEventStore\", new EventStore(this));\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureEventStores\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureTimeoutStores\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"handlers\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"config\", {});\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"pointerIds\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"touchIds\", new Set());\n    (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if ((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(event)) {\n      this.touchIds = new Set((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(event));\n      return this.touchIds;\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine = _actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey]((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(...props[handlerProp]);\n    }\n    if (!target) return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(handlerProp);\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n}\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : (0,_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n  if (!_actions_fe213e88_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.has(key)) {\n    if (true) {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOE87QUFDN007O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQix1REFBTztBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBc0M7QUFDbEQ7QUFDQTtBQUNBLFVBQVUsS0FBSyxFQUVOO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQix1REFBaUI7QUFDdEMsc0NBQXNDLDJEQUFjO0FBQ3BEO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLHVCQUF1Qix1REFBaUI7QUFDeEM7QUFDQSxtQ0FBbUMsMkRBQWM7QUFDakQ7QUFDQSxTQUFTO0FBQ1QsUUFBUSxTQUFTLElBQXNDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDJEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQWM7QUFDL0I7QUFDQSx5QkFBeUIsMkRBQWMsQ0FBQywyREFBYyxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDJEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksMkRBQWU7QUFDbkIsSUFBSSwyREFBZTtBQUNuQixJQUFJLDJEQUFlLCtCQUErQjtBQUNsRCxJQUFJLDJEQUFlLGlDQUFpQztBQUNwRCxJQUFJLDJEQUFlLHFCQUFxQjtBQUN4QyxJQUFJLDJEQUFlLG1CQUFtQjtBQUN0QyxJQUFJLDJEQUFlO0FBQ25CLElBQUksMkRBQWU7QUFDbkIsSUFBSSwyREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBTztBQUNmLDhCQUE4QiwyREFBUTtBQUN0QztBQUNBLE1BQU07QUFDTixnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwyREFBYyxDQUFDLDJEQUFjLEdBQUcsd0JBQXdCO0FBQ3hJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxFQUFFLDJEQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1REFBUztBQUNoQixRQUFRLElBQXNDO0FBQzlDLDJGQUEyRixJQUFJLDREQUE0RCxJQUFJO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGFya3Jvb20uZW5naW5lZXJpbmcvc2F0dXMvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLmVzbS5qcz83MWMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFMgYXMgU1VQUE9SVCwgQyBhcyBDb25maWdSZXNvbHZlck1hcCwgXyBhcyBfb2JqZWN0U3ByZWFkMiwgYSBhcyBfZGVmaW5lUHJvcGVydHksIHQgYXMgdG9Eb21FdmVudFR5cGUsIGkgYXMgaXNUb3VjaCwgYiBhcyB0b3VjaElkcywgRSBhcyBFbmdpbmVNYXAsIGMgYXMgY2hhaW4sIHAgYXMgcGFyc2VQcm9wLCBkIGFzIHRvSGFuZGxlclByb3AgfSBmcm9tICcuL2FjdGlvbnMtZmUyMTNlODguZXNtLmpzJztcbmltcG9ydCAnLi9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBzaGFyZWRDb25maWdSZXNvbHZlciA9IHtcbiAgdGFyZ2V0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKCkgPT4gJ2N1cnJlbnQnIGluIHZhbHVlID8gdmFsdWUuY3VycmVudCA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICBlbmFibGVkKHZhbHVlID0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgd2luZG93KHZhbHVlID0gU1VQUE9SVC5pc0Jyb3dzZXIgPyB3aW5kb3cgOiB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGV2ZW50T3B0aW9ucyh7XG4gICAgcGFzc2l2ZSA9IHRydWUsXG4gICAgY2FwdHVyZSA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzaXZlLFxuICAgICAgY2FwdHVyZVxuICAgIH07XG4gIH0sXG4gIHRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1widGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiLCBcInRyYW5zZm9ybVwiXTtcbmZ1bmN0aW9uIHJlc29sdmVXaXRoKGNvbmZpZyA9IHt9LCByZXNvbHZlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgcmVzb2x2ZXJdIG9mIE9iamVjdC5lbnRyaWVzKHJlc29sdmVycykpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiByZXNvbHZlcikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zdCByID0gcmVzb2x2ZXIuY2FsbChyZXN1bHQsIGNvbmZpZ1trZXldLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocikpIHJlc3VsdFtrZXldID0gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVyLmNhbGwocmVzdWx0LCBjb25maWdba2V5XSwga2V5LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlV2l0aChjb25maWdba2V5XSwgcmVzb2x2ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAocmVzb2x2ZXIpIHJlc3VsdFtrZXldID0gY29uZmlnW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2UobmV3Q29uZmlnLCBnZXN0dXJlS2V5LCBfY29uZmlnID0ge30pIHtcbiAgY29uc3QgX3JlZiA9IG5ld0NvbmZpZyxcbiAgICB7XG4gICAgICB0YXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3csXG4gICAgICBlbmFibGVkLFxuICAgICAgdHJhbnNmb3JtXG4gICAgfSA9IF9yZWYsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICBfY29uZmlnLnNoYXJlZCA9IHJlc29sdmVXaXRoKHtcbiAgICB0YXJnZXQsXG4gICAgZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdyxcbiAgICBlbmFibGVkLFxuICAgIHRyYW5zZm9ybVxuICB9LCBzaGFyZWRDb25maWdSZXNvbHZlcik7XG4gIGlmIChnZXN0dXJlS2V5KSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBDb25maWdSZXNvbHZlck1hcC5nZXQoZ2VzdHVyZUtleSk7XG4gICAgX2NvbmZpZ1tnZXN0dXJlS2V5XSA9IHJlc29sdmVXaXRoKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHNoYXJlZDogX2NvbmZpZy5zaGFyZWRcbiAgICB9LCByZXN0KSwgcmVzb2x2ZXIpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gQ29uZmlnUmVzb2x2ZXJNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgX2NvbmZpZ1trZXldID0gcmVzb2x2ZVdpdGgoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNoYXJlZDogX2NvbmZpZy5zaGFyZWRcbiAgICAgICAgfSwgcmVzdFtrZXldKSwgcmVzb2x2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAoIVsnZHJhZycsICdwaW5jaCcsICdzY3JvbGwnLCAnd2hlZWwnLCAnbW92ZScsICdob3ZlciddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnZG9tVGFyZ2V0Jykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBkb21UYXJnZXRcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdGFyZ2V0XFxgLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBVbmtub3duIGNvbmZpZyBrZXkgXFxgJHtrZXl9XFxgIHdhcyB1c2VkLiBQbGVhc2UgcmVhZCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gX2NvbmZpZztcbn1cblxuY2xhc3MgRXZlbnRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGN0cmwsIGdlc3R1cmVLZXkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGlzdGVuZXJzXCIsIG5ldyBTZXQoKSk7XG4gICAgdGhpcy5fY3RybCA9IGN0cmw7XG4gICAgdGhpcy5fZ2VzdHVyZUtleSA9IGdlc3R1cmVLZXk7XG4gIH1cbiAgYWRkKGVsZW1lbnQsIGRldmljZSwgYWN0aW9uLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHR5cGUgPSB0b0RvbUV2ZW50VHlwZShkZXZpY2UsIGFjdGlvbik7XG4gICAgY29uc3QgX29wdGlvbnMgPSB0aGlzLl9nZXN0dXJlS2V5ID8gdGhpcy5fY3RybC5jb25maWdbdGhpcy5fZ2VzdHVyZUtleV0uZXZlbnRPcHRpb25zIDoge307XG4gICAgY29uc3QgZXZlbnRPcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF9vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgY29uc3QgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKHJlbW92ZSk7XG4gICAgfTtcbiAgICBsaXN0ZW5lcnMuYWRkKHJlbW92ZSk7XG4gICAgcmV0dXJuIHJlbW92ZTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChyZW1vdmUgPT4gcmVtb3ZlKCkpO1xuICAgIHRoaXMuX2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5cbmNsYXNzIFRpbWVvdXRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lb3V0c1wiLCBuZXcgTWFwKCkpO1xuICB9XG4gIGFkZChrZXksIGNhbGxiYWNrLCBtcyA9IDE0MCwgLi4uYXJncykge1xuICAgIHRoaXMucmVtb3ZlKGtleSk7XG4gICAgdGhpcy5fdGltZW91dHMuc2V0KGtleSwgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5nZXQoa2V5KTtcbiAgICBpZiAodGltZW91dCkgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLl90aW1lb3V0cy5mb3JFYWNoKHRpbWVvdXQgPT4gdm9pZCB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgICB0aGlzLl90aW1lb3V0cy5jbGVhcigpO1xuICB9XG59XG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihoYW5kbGVycykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlc3R1cmVzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldEV2ZW50U3RvcmVcIiwgbmV3IEV2ZW50U3RvcmUodGhpcykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlc3R1cmVFdmVudFN0b3Jlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VzdHVyZVRpbWVvdXRTdG9yZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvaW50ZXJJZHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaElkc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIHNoYXJlZDoge1xuICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgYWx0S2V5OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc29sdmVHZXN0dXJlcyh0aGlzLCBoYW5kbGVycyk7XG4gIH1cbiAgc2V0RXZlbnRJZHMoZXZlbnQpIHtcbiAgICBpZiAoaXNUb3VjaChldmVudCkpIHtcbiAgICAgIHRoaXMudG91Y2hJZHMgPSBuZXcgU2V0KHRvdWNoSWRzKGV2ZW50KSk7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaElkcztcbiAgICB9IGVsc2UgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJ1cCcgfHwgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJjYW5jZWwnKSB0aGlzLnBvaW50ZXJJZHMuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7ZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykgdGhpcy5wb2ludGVySWRzLmFkZChldmVudC5wb2ludGVySWQpO1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRlcklkcztcbiAgICB9XG4gIH1cbiAgYXBwbHlIYW5kbGVycyhoYW5kbGVycywgbmF0aXZlSGFuZGxlcnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgdGhpcy5uYXRpdmVIYW5kbGVycyA9IG5hdGl2ZUhhbmRsZXJzO1xuICB9XG4gIGFwcGx5Q29uZmlnKGNvbmZpZywgZ2VzdHVyZUtleSkge1xuICAgIHRoaXMuY29uZmlnID0gcGFyc2UoY29uZmlnLCBnZXN0dXJlS2V5LCB0aGlzLmNvbmZpZyk7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5fdGFyZ2V0RXZlbnRTdG9yZS5jbGVhbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuZ2VzdHVyZXMpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZUV2ZW50U3RvcmVzW2tleV0uY2xlYW4oKTtcbiAgICAgIHRoaXMuZ2VzdHVyZVRpbWVvdXRTdG9yZXNba2V5XS5jbGVhbigpO1xuICAgIH1cbiAgfVxuICBlZmZlY3QoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNoYXJlZC50YXJnZXQpIHRoaXMuYmluZCgpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLl90YXJnZXRFdmVudFN0b3JlLmNsZWFuKCk7XG4gIH1cbiAgYmluZCguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2hhcmVkQ29uZmlnID0gdGhpcy5jb25maWcuc2hhcmVkO1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgbGV0IHRhcmdldDtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLnRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gc2hhcmVkQ29uZmlnLnRhcmdldCgpO1xuICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXJlZENvbmZpZy5lbmFibGVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGdlc3R1cmVLZXkgb2YgdGhpcy5nZXN0dXJlcykge1xuICAgICAgICBjb25zdCBnZXN0dXJlQ29uZmlnID0gdGhpcy5jb25maWdbZ2VzdHVyZUtleV07XG4gICAgICAgIGNvbnN0IGJpbmRGdW5jdGlvbiA9IGJpbmRUb1Byb3BzKHByb3BzLCBnZXN0dXJlQ29uZmlnLmV2ZW50T3B0aW9ucywgISF0YXJnZXQpO1xuICAgICAgICBpZiAoZ2VzdHVyZUNvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgRW5naW5lID0gRW5naW5lTWFwLmdldChnZXN0dXJlS2V5KTtcbiAgICAgICAgICBuZXcgRW5naW5lKHRoaXMsIGFyZ3MsIGdlc3R1cmVLZXkpLmJpbmQoYmluZEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbmF0aXZlQmluZEZ1bmN0aW9uID0gYmluZFRvUHJvcHMocHJvcHMsIHNoYXJlZENvbmZpZy5ldmVudE9wdGlvbnMsICEhdGFyZ2V0KTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnRLZXkgaW4gdGhpcy5uYXRpdmVIYW5kbGVycykge1xuICAgICAgICBuYXRpdmVCaW5kRnVuY3Rpb24oZXZlbnRLZXksICcnLCBldmVudCA9PiB0aGlzLm5hdGl2ZUhhbmRsZXJzW2V2ZW50S2V5XShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zdGF0ZS5zaGFyZWQpLCB7fSwge1xuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfSkpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGhhbmRsZXJQcm9wIGluIHByb3BzKSB7XG4gICAgICBwcm9wc1toYW5kbGVyUHJvcF0gPSBjaGFpbiguLi5wcm9wc1toYW5kbGVyUHJvcF0pO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIHByb3BzO1xuICAgIGZvciAoY29uc3QgaGFuZGxlclByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlXG4gICAgICB9ID0gcGFyc2VQcm9wKGhhbmRsZXJQcm9wKTtcbiAgICAgIHRoaXMuX3RhcmdldEV2ZW50U3RvcmUuYWRkKHRhcmdldCwgZGV2aWNlLCAnJywgcHJvcHNbaGFuZGxlclByb3BdLCB7XG4gICAgICAgIGNhcHR1cmUsXG4gICAgICAgIHBhc3NpdmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBHZXN0dXJlKGN0cmwsIGdlc3R1cmVLZXkpIHtcbiAgY3RybC5nZXN0dXJlcy5hZGQoZ2VzdHVyZUtleSk7XG4gIGN0cmwuZ2VzdHVyZUV2ZW50U3RvcmVzW2dlc3R1cmVLZXldID0gbmV3IEV2ZW50U3RvcmUoY3RybCwgZ2VzdHVyZUtleSk7XG4gIGN0cmwuZ2VzdHVyZVRpbWVvdXRTdG9yZXNbZ2VzdHVyZUtleV0gPSBuZXcgVGltZW91dFN0b3JlKCk7XG59XG5mdW5jdGlvbiByZXNvbHZlR2VzdHVyZXMoY3RybCwgaW50ZXJuYWxIYW5kbGVycykge1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5kcmFnKSBzZXR1cEdlc3R1cmUoY3RybCwgJ2RyYWcnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMud2hlZWwpIHNldHVwR2VzdHVyZShjdHJsLCAnd2hlZWwnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuc2Nyb2xsKSBzZXR1cEdlc3R1cmUoY3RybCwgJ3Njcm9sbCcpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5tb3ZlKSBzZXR1cEdlc3R1cmUoY3RybCwgJ21vdmUnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMucGluY2gpIHNldHVwR2VzdHVyZShjdHJsLCAncGluY2gnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuaG92ZXIpIHNldHVwR2VzdHVyZShjdHJsLCAnaG92ZXInKTtcbn1cbmNvbnN0IGJpbmRUb1Byb3BzID0gKHByb3BzLCBldmVudE9wdGlvbnMsIHdpdGhQYXNzaXZlT3B0aW9uKSA9PiAoZGV2aWNlLCBhY3Rpb24sIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSwgaXNOYXRpdmUgPSBmYWxzZSkgPT4ge1xuICB2YXIgX29wdGlvbnMkY2FwdHVyZSwgX29wdGlvbnMkcGFzc2l2ZTtcbiAgY29uc3QgY2FwdHVyZSA9IChfb3B0aW9ucyRjYXB0dXJlID0gb3B0aW9ucy5jYXB0dXJlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYXB0dXJlICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYXB0dXJlIDogZXZlbnRPcHRpb25zLmNhcHR1cmU7XG4gIGNvbnN0IHBhc3NpdmUgPSAoX29wdGlvbnMkcGFzc2l2ZSA9IG9wdGlvbnMucGFzc2l2ZSkgIT09IG51bGwgJiYgX29wdGlvbnMkcGFzc2l2ZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkcGFzc2l2ZSA6IGV2ZW50T3B0aW9ucy5wYXNzaXZlO1xuICBsZXQgaGFuZGxlclByb3AgPSBpc05hdGl2ZSA/IGRldmljZSA6IHRvSGFuZGxlclByb3AoZGV2aWNlLCBhY3Rpb24sIGNhcHR1cmUpO1xuICBpZiAod2l0aFBhc3NpdmVPcHRpb24gJiYgcGFzc2l2ZSkgaGFuZGxlclByb3AgKz0gJ1Bhc3NpdmUnO1xuICBwcm9wc1toYW5kbGVyUHJvcF0gPSBwcm9wc1toYW5kbGVyUHJvcF0gfHwgW107XG4gIHByb3BzW2hhbmRsZXJQcm9wXS5wdXNoKGhhbmRsZXIpO1xufTtcblxuY29uc3QgUkVfTk9UX05BVElWRSA9IC9eb24oRHJhZ3xXaGVlbHxTY3JvbGx8TW92ZXxQaW5jaHxIb3ZlcikvO1xuZnVuY3Rpb24gc29ydEhhbmRsZXJzKF9oYW5kbGVycykge1xuICBjb25zdCBuYXRpdmUgPSB7fTtcbiAgY29uc3QgaGFuZGxlcnMgPSB7fTtcbiAgY29uc3QgYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgZm9yIChsZXQga2V5IGluIF9oYW5kbGVycykge1xuICAgIGlmIChSRV9OT1RfTkFUSVZFLnRlc3Qoa2V5KSkge1xuICAgICAgYWN0aW9ucy5hZGQoUmVnRXhwLmxhc3RNYXRjaCk7XG4gICAgICBoYW5kbGVyc1trZXldID0gX2hhbmRsZXJzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdGl2ZVtrZXldID0gX2hhbmRsZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbaGFuZGxlcnMsIG5hdGl2ZSwgYWN0aW9uc107XG59XG5mdW5jdGlvbiByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsIGhhbmRsZXJLZXksIGtleSwgaW50ZXJuYWxIYW5kbGVycywgY29uZmlnKSB7XG4gIGlmICghYWN0aW9ucy5oYXMoaGFuZGxlcktleSkpIHJldHVybjtcbiAgaWYgKCFFbmdpbmVNYXAuaGFzKGtleSkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IFlvdSd2ZSBjcmVhdGVkIGEgY3VzdG9tIGhhbmRsZXIgdGhhdCB0aGF0IHVzZXMgdGhlIFxcYCR7a2V5fVxcYCBnZXN0dXJlIGJ1dCBpc24ndCBwcm9wZXJseSBjb25maWd1cmVkLlxcblxcblBsZWFzZSBhZGQgXFxgJHtrZXl9QWN0aW9uXFxgIHdoZW4gY3JlYXRpbmcgeW91ciBoYW5kbGVyLmApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhcnRLZXkgPSBoYW5kbGVyS2V5ICsgJ1N0YXJ0JztcbiAgY29uc3QgZW5kS2V5ID0gaGFuZGxlcktleSArICdFbmQnO1xuICBjb25zdCBmbiA9IHN0YXRlID0+IHtcbiAgICBsZXQgbWVtbyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuZmlyc3QgJiYgc3RhcnRLZXkgaW4gaGFuZGxlcnMpIGhhbmRsZXJzW3N0YXJ0S2V5XShzdGF0ZSk7XG4gICAgaWYgKGhhbmRsZXJLZXkgaW4gaGFuZGxlcnMpIG1lbW8gPSBoYW5kbGVyc1toYW5kbGVyS2V5XShzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmxhc3QgJiYgZW5kS2V5IGluIGhhbmRsZXJzKSBoYW5kbGVyc1tlbmRLZXldKHN0YXRlKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbiAgaW50ZXJuYWxIYW5kbGVyc1trZXldID0gZm47XG4gIGNvbmZpZ1trZXldID0gY29uZmlnW2tleV0gfHwge307XG59XG5mdW5jdGlvbiBwYXJzZU1lcmdlZEhhbmRsZXJzKG1lcmdlZEhhbmRsZXJzLCBtZXJnZWRDb25maWcpIHtcbiAgY29uc3QgW2hhbmRsZXJzLCBuYXRpdmVIYW5kbGVycywgYWN0aW9uc10gPSBzb3J0SGFuZGxlcnMobWVyZ2VkSGFuZGxlcnMpO1xuICBjb25zdCBpbnRlcm5hbEhhbmRsZXJzID0ge307XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uRHJhZycsICdkcmFnJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25XaGVlbCcsICd3aGVlbCcsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uU2Nyb2xsJywgJ3Njcm9sbCcsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uUGluY2gnLCAncGluY2gnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvbk1vdmUnLCAnbW92ZScsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uSG92ZXInLCAnaG92ZXInLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiBpbnRlcm5hbEhhbmRsZXJzLFxuICAgIGNvbmZpZzogbWVyZ2VkQ29uZmlnLFxuICAgIG5hdGl2ZUhhbmRsZXJzXG4gIH07XG59XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIHBhcnNlTWVyZ2VkSGFuZGxlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js ***!
  \******************************************************************************************************************************/
/***/ (() => {




/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rubberbandIfOutOfBounds: () => (/* reexport safe */ _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)\n/* harmony export */ });\n/* harmony import */ var _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/maths-0ab39ae9.esm.js */ \"(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B1c2UtZ2VzdHVyZStjb3JlQDEwLjMuMS9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BkYXJrcm9vbS5lbmdpbmVlcmluZy9zYXR1cy8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVzZS1nZXN0dXJlK2NvcmVAMTAuMy4xL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS91dGlscy9kaXN0L3VzZS1nZXN0dXJlLWNvcmUtdXRpbHMuZXNtLmpzP2RlNzYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgciBhcyBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyB9IGZyb20gJy4uLy4uL2Rpc3QvbWF0aHMtMGFiMzlhZTkuZXNtLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@use-gesture+core@10.3.1/node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js\n");

/***/ })

};
;