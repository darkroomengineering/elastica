"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(pages)/home/page",{

/***/ "(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs":
/*!***********************************************************!*\
  !*** ../packages/react/dist/elastic-collisions-react.mjs ***!
  \***********************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionBox: function() { return /* binding */ CollisionBox; },\n/* harmony export */   \"default\": function() { return /* binding */ ReactElasticCollision; },\n/* harmony export */   useElasticCollision: function() { return /* binding */ useElasticCollision; }\n/* harmony export */ });\n/* harmony import */ var _darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @darkroom.engineering/hamo */ \"(app-pages-browser)/../node_modules/.pnpm/@darkroom.engineering+hamo@0.6.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@darkroom.engineering/hamo/dist/hamo.modern.mjs\");\n/* harmony import */ var _use_gesture_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/react */ \"(app-pages-browser)/../node_modules/.pnpm/@use-gesture+react@10.3.1_react@18.3.1/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.4_@babel+core@7.24.9_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.8/node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\n\n\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(i) {\n        for(var t = 1; t < arguments.length; t++){\n            var s = arguments[t];\n            for(var o in s)({}).hasOwnProperty.call(s, o) && (i[o] = s[o]);\n        }\n        return i;\n    }, _extends.apply(null, arguments);\n}\nclass ElasticCollision {\n    initialConditions(i, t) {\n        let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>{};\n        this.container = t, this.dimensions = i.map((i)=>{\n            if (!i) return [\n                0,\n                0\n            ];\n            const { rect: t } = i;\n            return [\n                t.width / 2,\n                t.height / 2\n            ];\n        }), s(this), this.positions.forEach((t, s)=>{\n            var _i_s;\n            this.hash[s] = Math.floor(this.gridSize * (t[0] / this.container.width)) + Math.floor(this.gridSize * (t[1] / this.container.height)) * this.gridSize, this.setPosition((_i_s = i[s]) === null || _i_s === void 0 ? void 0 : _i_s.element, {\n                x: t[0],\n                y: t[1]\n            });\n        });\n    }\n    polarCoordinates(i) {\n        return {\n            speed: Math.sqrt(i[0] * i[0] + i[1] * i[1]),\n            angle: Math.atan2(i[1], i[0])\n        };\n    }\n    cartesianCoordinates(i, t) {\n        return [\n            i * Math.cos(t),\n            i * Math.sin(t)\n        ];\n    }\n    hasBounced(i) {\n        return this.bounced[i] += 1;\n    }\n    setPosition(i, param) {\n        let { x: t = 0, y: s = 0, z: o = 0 } = param;\n        i && (i.style.cssText = \"transform: translate3d(\".concat(t, \"px, \").concat(s, \"px, \").concat(o, \"px);\"));\n    }\n    rigidBorders(i) {\n        if (\"rigid\" === this.calculateBorders) for(let t = 0; t < i.length; t++){\n            const i = this.dimensions[t];\n            let s = this.velocities[t], o = this.positions[t];\n            o[1] < i[1] + this.container.height * this.containerOffsets.top && (this.hasBounced(t), this.velocities[t][1] = -s[1], this.positions[t][1] = i[1] + this.container.height * this.containerOffsets.top), o[0] < i[0] + this.container.width * this.containerOffsets.left && (this.hasBounced(t), this.velocities[t][0] = -s[0], this.positions[t][0] = i[0] + this.container.width * this.containerOffsets.left), o[1] > this.container.height * (this.containerOffsets.bottom + 1) - i[1] && (this.hasBounced(t), this.velocities[t][1] = -s[1], this.positions[t][1] = this.container.height * (this.containerOffsets.bottom + 1) - i[1]), o[0] > this.container.width * (this.containerOffsets.right + 1) - i[0] && (this.hasBounced(t), this.velocities[t][0] = -s[0], this.positions[t][0] = this.container.width * (this.containerOffsets.right + 1) - i[0]);\n        }\n    }\n    periodicBorders(i) {\n        if (\"periodic\" === this.calculateBorders) for(let t = 0; t < i.length; t++){\n            const i = this.dimensions[t];\n            let s = this.positions[t], o = this.velocities[t].map((i)=>Math.sign(i));\n            -1 === o[1] && s[1] < i[1] + this.container.height * this.containerOffsets.top && (this.positions[t][1] = i[1] + this.container.height * this.containerOffsets.bottom), 1 === o[1] && s[1] > this.container.height * this.containerOffsets.bottom - i[1] && (this.positions[t][1] = this.container.height * this.containerOffsets.top - i[1]), -1 === o[0] && s[0] < i[0] + this.container.width * this.containerOffsets.left && (this.positions[t][0] = i[0] + this.container.width * this.containerOffsets.right), 1 === o[0] && s[0] > this.container.width * this.containerOffsets.right - i[0] && (this.positions[t][0] = this.container.width * this.containerOffsets.left - i[0]);\n        }\n    }\n    isNeighboor(i, t) {\n        const s = this.hash[t];\n        let o = this.hash[i], e = !1;\n        for(let i = -1; i < 2; i++)for(let t = -1; t < 2; t++){\n            let n = o + this.gridSize * i + t;\n            if (!(n < 0 || n > this.gridSize * this.gridSize) && n === s) {\n                e = !0;\n                break;\n            }\n        }\n        return e;\n    }\n    axisAlignedBoundaryBoxes(i, t) {\n        const s = this.dimensions[i], o = this.positions[i], e = this.dimensions[t], n = this.positions[t];\n        return o.map((i, t)=>Math.abs(i - n[t]) < s[t] + e[t]).every((i)=>i);\n    }\n    calculateSuperposition(i, t) {\n        let s = [\n            0,\n            0\n        ];\n        const o = this.positions[i], e = this.dimensions[i], n = this.positions[t], r = this.dimensions[t], h = o.map((i, t)=>e[t] + r[t] - Math.abs(i - n[t]));\n        return h[0] < h[1] ? o[0] < n[0] ? s[0] = h[0] : s[0] = -h[0] : o[1] < n[1] ? s[1] = h[1] : s[1] = -h[1], s.map((i)=>i + Math.random() * this.collisionRandomness);\n    }\n    collisions(i) {\n        if (this.calculatecCollisions) {\n            this.collisionsList = [];\n            for(let t = 0; t < i.length; t++){\n                let i = this.velocities[t];\n                this.hash.forEach((s, o)=>{\n                    if (o === t) return;\n                    let e = this.velocities[o];\n                    if (this.collisionsList.some((param)=>{\n                        let { loop: i, inHash: s } = param;\n                        return i === o && s === t;\n                    })) return;\n                    if (!this.isNeighboor(t, o)) return;\n                    if (!this.axisAlignedBoundaryBoxes(t, o)) return;\n                    this.collisionsList.push({\n                        loop: t,\n                        inHash: o\n                    });\n                    const n = .5 * (i.reduce((i, t)=>i + t * t, 0) + e.reduce((i, t)=>i + t * t, 0)), r = this.calculateSuperposition(t, o);\n                    let h = i.map((i, t)=>i + r[t]), a = e.map((i, t)=>i - r[t]);\n                    const c = .5 * (h.reduce((i, t)=>i + t * t, 0) + a.reduce((i, t)=>i + t * t, 0));\n                    if (0 !== c) {\n                        const i = Math.sqrt(n / c);\n                        h = h.map((t)=>t * i), a = a.map((t)=>t * i);\n                    }\n                    this.velocities[t] = a, this.velocities[o] = h;\n                });\n            }\n        }\n    }\n    update(i, t) {\n        this.rigidBorders(i), this.periodicBorders(i), this.collisions(i), t(this), this.positions.forEach((i, t)=>{\n            this.hash[t] = Math.floor(this.gridSize * i[0] / this.container.width) + Math.floor(this.gridSize * i[1] / this.container.height) * this.gridSize;\n        });\n    }\n    constructor({ gridSize: i = 4, containerOffsets: t = {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n    }, collisions: s = !0, borders: o = \"rigid\", collisionRandomness: e = 0 } = {}){\n        this.calculatecCollisions = s, this.calculateBorders = o, this.collisionRandomness = e, this.gridSize = i, this.containerOffsets = t, this.positions = [], this.velocities = [], this.dimensions = [], this.bounced = [], this.hash = [], this.container = {}, this.collisionsList = [];\n    }\n}\nconst l = {\n    random: function randomInitialConditions(param) {\n        let { boxes: i, positions: t, velocities: s, container: o } = param;\n        i.forEach((i, e)=>{\n            t[e] = [\n                Math.random() * o.width,\n                Math.random() * o.height\n            ], s[e] = [\n                .5 * (Math.random() - .5),\n                .5 * (Math.random() - .5)\n            ];\n        });\n    }\n};\nconst d = {\n    dvdAnimation: function dvdAnimation(param) {\n        let { boxes: i, positions: t, velocities: s, deltaTime: o } = param;\n        i.forEach((i, e)=>{\n            const n = s[e], r = t[e];\n            t[e] = r.map((i, t)=>i + n[t] * o);\n        });\n    }\n};\nconst f = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useElasticCollision() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(f);\n}\nfunction ReactElasticCollision(param) {\n    let { children: s, className: e, config: c = {\n        gridSize: 8,\n        collisions: !1,\n        borders: \"rigid\",\n        containerOffsets: {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        }\n    }, presets: u = {\n        initialConditions: null,\n        update: null\n    }, initialConditions: p = ()=>{}, update: m = ()=>{} } = param;\n    const g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map), [v, x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(u), [C, b] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), [B] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new ElasticCollision(c)), O = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((i, t)=>{\n        g.current.set(i, t);\n    }, []), E = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((i)=>{\n        g.current.delete(i);\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let i = u.initialConditions, t = u.update;\n        (u === null || u === void 0 ? void 0 : u.initialConditions) ? (i = l[u.initialConditions], i || (console.log(\"No setup preset found for \".concat(u.initialConditions, \" defaulting to random\")), i = l.random)) : i = p, u.update ? (t = d[u.update], t || (console.log(\"No update preset found for \".concat(u.update, \" defaulting to dvdAnimation\")), t = d.dvdAnimation)) : t = m, x({\n            initialConditions: i,\n            update: t\n        });\n    }, [\n        u\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const i = [\n            ...g.current.values()\n        ];\n        (function isEmptyArray(i) {\n            return !i || Array.isArray(i) && 0 === i.length;\n        })(i) || i.some((param)=>{\n            let { rect: i } = param;\n            return !i;\n        }) || (console.log(v), v.initialConditions && B.initialConditions(i, b, (t)=>v.initialConditions({\n                boxes: i,\n                ...t\n            })));\n    }, [\n        B,\n        b,\n        p,\n        v\n    ]), (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useFrame)((i, t)=>{\n        const s = [\n            ...g.current.values()\n        ];\n        B.update(s, (i)=>{\n            u.update({\n                boxes: s,\n                ...i,\n                deltaTime: t\n            }), s.forEach((t, s)=>{\n                const o = i.positions[s], e = i.dimensions[s];\n                i === null || i === void 0 ? void 0 : i.setPosition(t === null || t === void 0 ? void 0 : t.element, {\n                    x: o[0] - e[0],\n                    y: o[1]\n                });\n            });\n        });\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: e,\n        ref: C,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(f.Provider, {\n        value: {\n            addBox: O,\n            removeBox: E\n        }\n    }, s));\n}\n_c = ReactElasticCollision;\nfunction CollisionBox(param) {\n    let { className: t, children: e, onDragStop: r = ()=>{}, ...h } = param;\n    _s();\n    const { addBox: c, removeBox: l } = useElasticCollision(), [d, f] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (u.current) return c(u.current, {\n            element: u.current,\n            rect: f\n        }), ()=>{\n            l(u.current);\n        };\n    }, [\n        f,\n        c,\n        l\n    ]);\n    const p = (0,_use_gesture_react__WEBPACK_IMPORTED_MODULE_2__.useDrag)((param)=>{\n        let { down: i, movement: [t, s] } = param;\n        i && r([\n            t,\n            s\n        ]);\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: (i)=>{\n            u.current = i, d(i);\n        },\n        className: t\n    }, h), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", p(), e));\n}\n_s(CollisionBox, \"6CmlvcLHWPJxczwlJYyGQTZayS0=\", false, function() {\n    return [\n        useElasticCollision,\n        useElasticCollision,\n        useElasticCollision\n    ];\n});\n_c1 = CollisionBox;\n //# sourceMappingURL=elastic-collisions-react.mjs.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ReactElasticCollision\");\n$RefreshReg$(_c1, \"CollisionBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9wYWNrYWdlcy9yZWFjdC9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BO0lBQWtaQyxrQkFBa0JDLENBQUFBLEVBQUVDLENBQUFBLEVBQUk7WUFBRkMsSUFBQUEsaUVBQUU7UUFBUUMsSUFBQUEsQ0FBS0MsU0FBQUEsR0FBVUgsR0FBRUUsSUFBQUEsQ0FBS0UsVUFBQUEsR0FBV0wsRUFBRU0sR0FBQUEsQ0FBS04sQ0FBQUE7WUFBSSxLQUFJQSxHQUFFLE9BQU07Z0JBQUM7Z0JBQUU7YUFBQTtZQUFHLFFBQU1PLE1BQUtOLENBQUFBLEVBQUFBLEdBQUdEO1lBQUUsT0FBTTtnQkFBQ0MsRUFBRU8sS0FBQUEsR0FBTTtnQkFBRVAsRUFBRVEsTUFBQUEsR0FBTzthQUFHO1FBQUEsSUFBR1AsRUFBRUMsSUFBQUEsR0FBTUEsSUFBQUEsQ0FBS08sU0FBQUEsQ0FBVUMsT0FBQUEsQ0FBUyxDQUFDVixHQUFFQztnQkFBOEpGO1lBQXpKRyxJQUFBQSxDQUFLUyxJQUFBQSxDQUFLVixFQUFBQSxHQUFHVyxLQUFLQyxLQUFBQSxDQUFNWCxJQUFBQSxDQUFLWSxRQUFBQSxHQUFVZCxDQUFBQSxDQUFBQSxDQUFFLEtBQUdFLElBQUFBLENBQUtDLFNBQUFBLENBQVVJLEtBQUFBLEtBQVFLLEtBQUtDLEtBQUFBLENBQU1YLElBQUFBLENBQUtZLFFBQUFBLEdBQVVkLENBQUFBLENBQUFBLENBQUUsS0FBR0UsSUFBQUEsQ0FBS0MsU0FBQUEsQ0FBVUssTUFBQUEsS0FBU04sSUFBQUEsQ0FBS1ksUUFBQUEsRUFBU1osSUFBQUEsQ0FBS2EsV0FBQUEsRUFBWWhCLE9BQUFBLENBQUFBLENBQUVFLEVBQUFBLGNBQUZGLDJCQUFBQSxLQUFNaUIsT0FBQUEsRUFBUTtnQkFBQ0MsR0FBRWpCLENBQUFBLENBQUU7Z0JBQUdrQixHQUFFbEIsQ0FBQUEsQ0FBRTtZ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bEI7SUFHRixxQkFDRWYsZ0RBQUFDLENBQUEsT0FBQWUsU0FBQTtRQUNFZCxLQUFNZSxDQUFBQTtZQUNKUixFQUFXMUIsT0FBQUEsR0FBVWtDLEdBQ3JCVCxFQUFXUztRQUFLO1FBRWxCbEQsV0FBV0E7SUFBQUEsR0FDUHVDLGtCQUVKTixnREFBQUMsQ0FBQSxPQUFTUyxLQUFTNUM7QUFHeEI7R0F6Q1N1Qzs7UUFNdUIxQztRQUFBQTtRQUFBQTs7O01BTnZCMEM7QUF5Q1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2VuZ2luZS9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy5tanM/NDA5MCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wcmVzZXRzLmpzP2FjMDIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvaW5kZXguanM/NWE2MCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy91dGlscy5qcz9hY2UwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEVsYXN0aWNDb2xsaXNpb257Y29uc3RydWN0b3Ioe2dyaWRTaXplOmk9NCxjb250YWluZXJPZmZzZXRzOnQ9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowfSxjb2xsaXNpb25zOnM9ITAsYm9yZGVyczpvPVwicmlnaWRcIixjb2xsaXNpb25SYW5kb21uZXNzOmU9MH09e30pe3RoaXMuY2FsY3VsYXRlY0NvbGxpc2lvbnM9cyx0aGlzLmNhbGN1bGF0ZUJvcmRlcnM9byx0aGlzLmNvbGxpc2lvblJhbmRvbW5lc3M9ZSx0aGlzLmdyaWRTaXplPWksdGhpcy5jb250YWluZXJPZmZzZXRzPXQsdGhpcy5wb3NpdGlvbnM9W10sdGhpcy52ZWxvY2l0aWVzPVtdLHRoaXMuZGltZW5zaW9ucz1bXSx0aGlzLmJvdW5jZWQ9W10sdGhpcy5oYXNoPVtdLHRoaXMuY29udGFpbmVyPXt9LHRoaXMuY29sbGlzaW9uc0xpc3Q9W119aW5pdGlhbENvbmRpdGlvbnMoaSx0LHM9KCk9Pnt9KXt0aGlzLmNvbnRhaW5lcj10LHRoaXMuZGltZW5zaW9ucz1pLm1hcCgoaT0+e2lmKCFpKXJldHVyblswLDBdO2NvbnN0e3JlY3Q6dH09aTtyZXR1cm5bdC53aWR0aC8yLHQuaGVpZ2h0LzJdfSkpLHModGhpcyksdGhpcy5wb3NpdGlvbnMuZm9yRWFjaCgoKHQscyk9Pnt0aGlzLmhhc2hbc109TWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKih0WzBdL3RoaXMuY29udGFpbmVyLndpZHRoKSkrTWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKih0WzFdL3RoaXMuY29udGFpbmVyLmhlaWdodCkpKnRoaXMuZ3JpZFNpemUsdGhpcy5zZXRQb3NpdGlvbihpW3NdPy5lbGVtZW50LHt4OnRbMF0seTp0WzFdfSl9KSl9cG9sYXJDb29yZGluYXRlcyhpKXtyZXR1cm57c3BlZWQ6TWF0aC5zcXJ0KGlbMF0qaVswXStpWzFdKmlbMV0pLGFuZ2xlOk1hdGguYXRhbjIoaVsxXSxpWzBdKX19Y2FydGVzaWFuQ29vcmRpbmF0ZXMoaSx0KXtyZXR1cm5baSpNYXRoLmNvcyh0KSxpKk1hdGguc2luKHQpXX1oYXNCb3VuY2VkKGkpe3JldHVybiB0aGlzLmJvdW5jZWRbaV0rPTF9c2V0UG9zaXRpb24oaSx7eDp0PTAseTpzPTAsejpvPTB9KXtpJiYoaS5zdHlsZS5jc3NUZXh0PWB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCR7dH1weCwgJHtzfXB4LCAke299cHgpO2ApfXJpZ2lkQm9yZGVycyhpKXtpZihcInJpZ2lkXCI9PT10aGlzLmNhbGN1bGF0ZUJvcmRlcnMpZm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5kaW1lbnNpb25zW3RdO2xldCBzPXRoaXMudmVsb2NpdGllc1t0XSxvPXRoaXMucG9zaXRpb25zW3RdO29bMV08aVsxXSt0aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLnRvcCYmKHRoaXMuaGFzQm91bmNlZCh0KSx0aGlzLnZlbG9jaXRpZXNbdF1bMV09LXNbMV0sdGhpcy5wb3NpdGlvbnNbdF1bMV09aVsxXSt0aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLnRvcCksb1swXTxpWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5sZWZ0JiYodGhpcy5oYXNCb3VuY2VkKHQpLHRoaXMudmVsb2NpdGllc1t0XVswXT0tc1swXSx0aGlzLnBvc2l0aW9uc1t0XVswXT1pWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5sZWZ0KSxvWzFdPnRoaXMuY29udGFpbmVyLmhlaWdodCoodGhpcy5jb250YWluZXJPZmZzZXRzLmJvdHRvbSsxKS1pWzFdJiYodGhpcy5oYXNCb3VuY2VkKHQpLHRoaXMudmVsb2NpdGllc1t0XVsxXT0tc1sxXSx0aGlzLnBvc2l0aW9uc1t0XVsxXT10aGlzLmNvbnRhaW5lci5oZWlnaHQqKHRoaXMuY29udGFpbmVyT2Zmc2V0cy5ib3R0b20rMSktaVsxXSksb1swXT50aGlzLmNvbnRhaW5lci53aWR0aCoodGhpcy5jb250YWluZXJPZmZzZXRzLnJpZ2h0KzEpLWlbMF0mJih0aGlzLmhhc0JvdW5jZWQodCksdGhpcy52ZWxvY2l0aWVzW3RdWzBdPS1zWzBdLHRoaXMucG9zaXRpb25zW3RdWzBdPXRoaXMuY29udGFpbmVyLndpZHRoKih0aGlzLmNvbnRhaW5lck9mZnNldHMucmlnaHQrMSktaVswXSl9fXBlcmlvZGljQm9yZGVycyhpKXtpZihcInBlcmlvZGljXCI9PT10aGlzLmNhbGN1bGF0ZUJvcmRlcnMpZm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5kaW1lbnNpb25zW3RdO2xldCBzPXRoaXMucG9zaXRpb25zW3RdLG89dGhpcy52ZWxvY2l0aWVzW3RdLm1hcCgoaT0+TWF0aC5zaWduKGkpKSk7LTE9PT1vWzFdJiZzWzFdPGlbMV0rdGhpcy5jb250YWluZXIuaGVpZ2h0KnRoaXMuY29udGFpbmVyT2Zmc2V0cy50b3AmJih0aGlzLnBvc2l0aW9uc1t0XVsxXT1pWzFdK3RoaXMuY29udGFpbmVyLmhlaWdodCp0aGlzLmNvbnRhaW5lck9mZnNldHMuYm90dG9tKSwxPT09b1sxXSYmc1sxXT50aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLmJvdHRvbS1pWzFdJiYodGhpcy5wb3NpdGlvbnNbdF1bMV09dGhpcy5jb250YWluZXIuaGVpZ2h0KnRoaXMuY29udGFpbmVyT2Zmc2V0cy50b3AtaVsxXSksLTE9PT1vWzBdJiZzWzBdPGlbMF0rdGhpcy5jb250YWluZXIud2lkdGgqdGhpcy5jb250YWluZXJPZmZzZXRzLmxlZnQmJih0aGlzLnBvc2l0aW9uc1t0XVswXT1pWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5yaWdodCksMT09PW9bMF0mJnNbMF0+dGhpcy5jb250YWluZXIud2lkdGgqdGhpcy5jb250YWluZXJPZmZzZXRzLnJpZ2h0LWlbMF0mJih0aGlzLnBvc2l0aW9uc1t0XVswXT10aGlzLmNvbnRhaW5lci53aWR0aCp0aGlzLmNvbnRhaW5lck9mZnNldHMubGVmdC1pWzBdKX19aXNOZWlnaGJvb3IoaSx0KXtjb25zdCBzPXRoaXMuaGFzaFt0XTtsZXQgbz10aGlzLmhhc2hbaV0sZT0hMTtmb3IobGV0IGk9LTE7aTwyO2krKylmb3IobGV0IHQ9LTE7dDwyO3QrKyl7bGV0IGg9byt0aGlzLmdyaWRTaXplKmkrdDtpZighKGg8MHx8aD50aGlzLmdyaWRTaXplKnRoaXMuZ3JpZFNpemUpJiZoPT09cyl7ZT0hMDticmVha319cmV0dXJuIGV9YXhpc0FsaWduZWRCb3VuZGFyeUJveGVzKGksdCl7Y29uc3Qgcz10aGlzLmRpbWVuc2lvbnNbaV0sbz10aGlzLnBvc2l0aW9uc1tpXSxlPXRoaXMuZGltZW5zaW9uc1t0XSxoPXRoaXMucG9zaXRpb25zW3RdO3JldHVybiBvLm1hcCgoKGksdCk9Pk1hdGguYWJzKGktaFt0XSk8c1t0XStlW3RdKSkuZXZlcnkoKGk9PmkpKX1jYWxjdWxhdGVTdXBlcnBvc2l0aW9uKGksdCl7bGV0IHM9WzAsMF07Y29uc3Qgbz10aGlzLnBvc2l0aW9uc1tpXSxlPXRoaXMuZGltZW5zaW9uc1tpXSxoPXRoaXMucG9zaXRpb25zW3RdLG49dGhpcy5kaW1lbnNpb25zW3RdLHI9by5tYXAoKChpLHQpPT5lW3RdK25bdF0tTWF0aC5hYnMoaS1oW3RdKSkpO3JldHVybiByWzBdPHJbMV0/b1swXTxoWzBdP3NbMF09clswXTpzWzBdPS1yWzBdOm9bMV08aFsxXT9zWzFdPXJbMV06c1sxXT0tclsxXSxzLm1hcCgoaT0+aStNYXRoLnJhbmRvbSgpKnRoaXMuY29sbGlzaW9uUmFuZG9tbmVzcykpfWNvbGxpc2lvbnMoaSl7aWYodGhpcy5jYWxjdWxhdGVjQ29sbGlzaW9ucyl7dGhpcy5jb2xsaXNpb25zTGlzdD1bXTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrKyl7bGV0IGk9dGhpcy52ZWxvY2l0aWVzW3RdO3RoaXMuaGFzaC5mb3JFYWNoKCgocyxvKT0+e2lmKG89PT10KXJldHVybjtsZXQgZT10aGlzLnZlbG9jaXRpZXNbb107aWYodGhpcy5jb2xsaXNpb25zTGlzdC5zb21lKCgoe2xvb3A6aSxpbkhhc2g6c30pPT5pPT09byYmcz09PXQpKSlyZXR1cm47aWYoIXRoaXMuaXNOZWlnaGJvb3IodCxvKSlyZXR1cm47aWYoIXRoaXMuYXhpc0FsaWduZWRCb3VuZGFyeUJveGVzKHQsbykpcmV0dXJuO3RoaXMuY29sbGlzaW9uc0xpc3QucHVzaCh7bG9vcDp0LGluSGFzaDpvfSk7Y29uc3QgaD0uNSooaS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkrZS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkpLG49dGhpcy5jYWxjdWxhdGVTdXBlcnBvc2l0aW9uKHQsbyk7bGV0IHI9aS5tYXAoKChpLHQpPT5pK25bdF0pKSxhPWUubWFwKCgoaSx0KT0+aS1uW3RdKSk7Y29uc3QgYz0uNSooci5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkrYS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkpO2lmKDAhPT1jKXtjb25zdCBpPU1hdGguc3FydChoL2MpO3I9ci5tYXAoKHQ9PnQqaSkpLGE9YS5tYXAoKHQ9PnQqaSkpfXRoaXMudmVsb2NpdGllc1t0XT1hLHRoaXMudmVsb2NpdGllc1tvXT1yfSkpfX19dXBkYXRlKGksdCl7dGhpcy5yaWdpZEJvcmRlcnMoaSksdGhpcy5wZXJpb2RpY0JvcmRlcnMoaSksdGhpcy5jb2xsaXNpb25zKGkpLHQodGhpcyksdGhpcy5wb3NpdGlvbnMuZm9yRWFjaCgoKGksdCk9Pnt0aGlzLmhhc2hbdF09TWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKmlbMF0vdGhpcy5jb250YWluZXIud2lkdGgpK01hdGguZmxvb3IodGhpcy5ncmlkU2l6ZSppWzFdL3RoaXMuY29udGFpbmVyLmhlaWdodCkqdGhpcy5ncmlkU2l6ZX0pKX19ZXhwb3J0e0VsYXN0aWNDb2xsaXNpb24gYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGFzdGljLWNvbGxpc2lvbnMubWpzLm1hcFxuIiwiZnVuY3Rpb24gcmFuZG9tSW5pdGlhbENvbmRpdGlvbnMoeyBib3hlcywgcG9zaXRpb25zLCB2ZWxvY2l0aWVzLCBjb250YWluZXIgfSkge1xuICBib3hlcy5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgIHBvc2l0aW9uc1tpbmRleF0gPSBbXG4gICAgICBNYXRoLnJhbmRvbSgpICogY29udGFpbmVyLndpZHRoLFxuICAgICAgTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci5oZWlnaHQsXG4gICAgXVxuICAgIHZlbG9jaXRpZXNbaW5kZXhdID0gW1xuICAgICAgMC41ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpLFxuICAgICAgMC41ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpLFxuICAgIF1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRhbENvbmRpdGlvbnNQcmVzZXRzTGliID0ge1xuICByYW5kb206IHJhbmRvbUluaXRpYWxDb25kaXRpb25zLFxufVxuXG5mdW5jdGlvbiBkdmRBbmltYXRpb24oeyBib3hlcywgcG9zaXRpb25zLCB2ZWxvY2l0aWVzLCBkZWx0YVRpbWUgfSkge1xuICBib3hlcy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gdmVsb2NpdGllc1tpbmRleF1cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpbmRleF1cblxuICAgIHBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbi5tYXAoKHBvcywgaSkgPT4gcG9zICsgdmVsb2NpdHlbaV0gKiBkZWx0YVRpbWUpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVQcmVzZXRzTGliID0ge1xuICBkdmRBbmltYXRpb24sXG59XG4iLCJpbXBvcnQgeyB1c2VGcmFtZSwgdXNlUmVjdCB9IGZyb20gJ0BkYXJrcm9vbS5lbmdpbmVlcmluZy9oYW1vJ1xuaW1wb3J0IHsgdXNlRHJhZyB9IGZyb20gJ0B1c2UtZ2VzdHVyZS9yZWFjdCdcbmltcG9ydCBSZWFjdCwge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0LFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCBFbGFzdGljQ29sbGlzaW9uIGZyb20gJy4uLy4uL2VuZ2luZS9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy5tanMnXG5pbXBvcnQgeyBpbml0YWxDb25kaXRpb25zUHJlc2V0c0xpYiwgdXBkYXRlUHJlc2V0c0xpYiB9IGZyb20gJy4vcHJlc2V0cydcbmltcG9ydCB7IGlzRW1wdHlBcnJheSB9IGZyb20gJy4vdXRpbHMnXG5cbmNvbnN0IEVsYXN0aWNDb2xsaXNpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSlcblxuZnVuY3Rpb24gdXNlRWxhc3RpY0NvbGxpc2lvbigpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIFJlYWN0RWxhc3RpY0NvbGxpc2lvbih7XG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWUsXG4gIGNvbmZpZyA9IHtcbiAgICBncmlkU2l6ZTogOCxcbiAgICBjb2xsaXNpb25zOiBmYWxzZSxcbiAgICBib3JkZXJzOiAncmlnaWQnLFxuICAgIGNvbnRhaW5lck9mZnNldHM6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICB9LFxuICB9LFxuICBwcmVzZXRzID0ge1xuICAgIGluaXRpYWxDb25kaXRpb25zOiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgfSxcbiAgaW5pdGlhbENvbmRpdGlvbnMgPSAoKSA9PiB7fSxcbiAgdXBkYXRlID0gKCkgPT4ge30sXG59KSB7XG4gIGNvbnN0IGJveGVzUmVmcyA9IHVzZVJlZihuZXcgTWFwKCkpXG4gIGNvbnN0IFtzZWxlY3RlZFByZXNldCwgc2V0U2VsZWN0ZWRQcmVzZXRdID0gdXNlU3RhdGUocHJlc2V0cylcbiAgY29uc3QgW3NlY3Rpb25SZWN0UmVmLCBzZWN0aW9uUmVjdF0gPSB1c2VSZWN0KClcbiAgY29uc3QgW2VsYXN0aWNDb2xsaXNpb25dID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVsYXN0aWNDb2xsaXNpb24oY29uZmlnKSlcblxuICBjb25zdCBhZGRCb3ggPSB1c2VDYWxsYmFjaygoZWxlbWVudCwgc2xpZGUpID0+IHtcbiAgICBib3hlc1JlZnMuY3VycmVudC5zZXQoZWxlbWVudCwgc2xpZGUpXG4gIH0sIFtdKVxuICBjb25zdCByZW1vdmVCb3ggPSB1c2VDYWxsYmFjaygoZWxlbWVudCkgPT4ge1xuICAgIGJveGVzUmVmcy5jdXJyZW50LmRlbGV0ZShlbGVtZW50KVxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBzZWxlY3RlZElDID0gcHJlc2V0cy5pbml0aWFsQ29uZGl0aW9uc1xuICAgIGxldCBzZWxlY3RlZFVwZGF0ZSA9IHByZXNldHMudXBkYXRlXG5cbiAgICBpZiAocHJlc2V0cz8uaW5pdGlhbENvbmRpdGlvbnMpIHtcbiAgICAgIHNlbGVjdGVkSUMgPSBpbml0YWxDb25kaXRpb25zUHJlc2V0c0xpYltwcmVzZXRzLmluaXRpYWxDb25kaXRpb25zXVxuXG4gICAgICBpZiAoIXNlbGVjdGVkSUMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYE5vIHNldHVwIHByZXNldCBmb3VuZCBmb3IgJHtwcmVzZXRzLmluaXRpYWxDb25kaXRpb25zfSBkZWZhdWx0aW5nIHRvIHJhbmRvbWBcbiAgICAgICAgKVxuXG4gICAgICAgIHNlbGVjdGVkSUMgPSBpbml0YWxDb25kaXRpb25zUHJlc2V0c0xpYi5yYW5kb21cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRJQyA9IGluaXRpYWxDb25kaXRpb25zXG4gICAgfVxuXG4gICAgaWYgKHByZXNldHMudXBkYXRlKSB7XG4gICAgICBzZWxlY3RlZFVwZGF0ZSA9IHVwZGF0ZVByZXNldHNMaWJbcHJlc2V0cy51cGRhdGVdXG5cbiAgICAgIGlmICghc2VsZWN0ZWRVcGRhdGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYE5vIHVwZGF0ZSBwcmVzZXQgZm91bmQgZm9yICR7cHJlc2V0cy51cGRhdGV9IGRlZmF1bHRpbmcgdG8gZHZkQW5pbWF0aW9uYFxuICAgICAgICApXG5cbiAgICAgICAgc2VsZWN0ZWRVcGRhdGUgPSB1cGRhdGVQcmVzZXRzTGliLmR2ZEFuaW1hdGlvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFVwZGF0ZSA9IHVwZGF0ZVxuICAgIH1cblxuICAgIHNldFNlbGVjdGVkUHJlc2V0KHtcbiAgICAgIGluaXRpYWxDb25kaXRpb25zOiBzZWxlY3RlZElDLFxuICAgICAgdXBkYXRlOiBzZWxlY3RlZFVwZGF0ZSxcbiAgICB9KVxuICB9LCBbcHJlc2V0c10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBib3hlcyA9IFsuLi5ib3hlc1JlZnMuY3VycmVudC52YWx1ZXMoKV1cblxuICAgIGlmIChpc0VtcHR5QXJyYXkoYm94ZXMpIHx8IGJveGVzLnNvbWUoKHsgcmVjdCB9KSA9PiAhcmVjdCkpIHJldHVyblxuXG4gICAgY29uc29sZS5sb2coc2VsZWN0ZWRQcmVzZXQpXG5cbiAgICBpZiAoIXNlbGVjdGVkUHJlc2V0LmluaXRpYWxDb25kaXRpb25zKSByZXR1cm5cblxuICAgIGVsYXN0aWNDb2xsaXNpb24uaW5pdGlhbENvbmRpdGlvbnMoYm94ZXMsIHNlY3Rpb25SZWN0LCAoaW5zdGFuY2VzKSA9PlxuICAgICAgc2VsZWN0ZWRQcmVzZXQuaW5pdGlhbENvbmRpdGlvbnMoeyBib3hlcywgLi4uaW5zdGFuY2VzIH0pXG4gICAgKVxuICB9LCBbZWxhc3RpY0NvbGxpc2lvbiwgc2VjdGlvblJlY3QsIGluaXRpYWxDb25kaXRpb25zLCBzZWxlY3RlZFByZXNldF0pXG5cbiAgdXNlRnJhbWUoKF8sIGRlbHRhVGltZSkgPT4ge1xuICAgIGNvbnN0IGJveGVzID0gWy4uLmJveGVzUmVmcy5jdXJyZW50LnZhbHVlcygpXVxuXG4gICAgZWxhc3RpY0NvbGxpc2lvbi51cGRhdGUoYm94ZXMsIChpbnN0YW5jZSkgPT4ge1xuICAgICAgcHJlc2V0cy51cGRhdGUoeyBib3hlcywgLi4uaW5zdGFuY2UsIGRlbHRhVGltZSB9KVxuXG4gICAgICBib3hlcy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluc3RhbmNlLnBvc2l0aW9uc1tpbmRleF1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGluc3RhbmNlLmRpbWVuc2lvbnNbaW5kZXhdXG5cbiAgICAgICAgaW5zdGFuY2U/LnNldFBvc2l0aW9uKGVsZW1lbnQ/LmVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBzaGlmdCBjZW50ZXJzIGVsZW1lbnQgdG8gY2VudGVyIG9mIG1hc3NcbiAgICAgICAgICB4OiBwb3NpdGlvblswXSAtIGRpbWVuc2lvbnNbMF0sXG4gICAgICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgIHJlZj17c2VjdGlvblJlY3RSZWZ9XG4gICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX1cbiAgICA+XG4gICAgICA8RWxhc3RpY0NvbGxpc2lvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgYWRkQm94LCByZW1vdmVCb3ggfX0+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZnVuY3Rpb24gQ29sbGlzaW9uQm94KHtcbiAgY2xhc3NOYW1lLFxuICBjaGlsZHJlbixcbiAgb25EcmFnU3RvcCA9ICgpID0+IHt9LFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IGFkZEJveCwgcmVtb3ZlQm94IH0gPSB1c2VFbGFzdGljQ29sbGlzaW9uKClcbiAgY29uc3QgW3NldFJlY3RSZWYsIHJlY3RdID0gdXNlUmVjdCgpXG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgYWRkQm94KGVsZW1lbnRSZWYuY3VycmVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgIHJlY3QsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZW1vdmVCb3goZWxlbWVudFJlZi5jdXJyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlY3QsIGFkZEJveCwgcmVtb3ZlQm94XSlcblxuICBjb25zdCBiaW5kID0gdXNlRHJhZygoeyBkb3duLCBtb3ZlbWVudDogW214LCBteV0gfSkgPT4ge1xuICAgIGlmIChkb3duKSB7XG4gICAgICBvbkRyYWdTdG9wKFtteCwgbXldKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17KG5vZGUpID0+IHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gbm9kZVxuICAgICAgICBzZXRSZWN0UmVmKG5vZGUpXG4gICAgICB9fVxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgPlxuICAgICAgPGRpdiB7Li4uYmluZCgpfT57Y2hpbGRyZW59PC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RFbGFzdGljQ29sbGlzaW9uXG5leHBvcnQgeyBDb2xsaXNpb25Cb3gsIHVzZUVsYXN0aWNDb2xsaXNpb24gfVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlBcnJheShhcnIpIHtcbiAgaWYgKCFhcnIpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID09PSAwXG59XG4iXSwibmFtZXMiOlsiRWxhc3RpY0NvbGxpc2lvbiIsImluaXRpYWxDb25kaXRpb25zIiwiaSIsInQiLCJzIiwidGhpcyIsImNvbnRhaW5lciIsImRpbWVuc2lvbnMiLCJtYXAiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbnMiLCJmb3JFYWNoIiwiaGFzaCIsIk1hdGgiLCJmbG9vciIsImdyaWRTaXplIiwic2V0UG9zaXRpb24iLCJlbGVtZW50IiwieCIsInkiLCJwb2xhckNvb3JkaW5hdGVzIiwic3BlZWQiLCJzcXJ0IiwiYW5nbGUiLCJhdGFuMiIsImNhcnRlc2lhbkNvb3JkaW5hdGVzIiwiY29zIiwic2luIiwiaGFzQm91bmNlZCIsImJvdW5jZWQiLCJ6IiwibyIsInN0eWxlIiwiY3NzVGV4dCIsInJpZ2lkQm9yZGVycyIsImNhbGN1bGF0ZUJvcmRlcnMiLCJsZW5ndGgiLCJ2ZWxvY2l0aWVzIiwiY29udGFpbmVyT2Zmc2V0cyIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInBlcmlvZGljQm9yZGVycyIsInNpZ24iLCJpc05laWdoYm9vciIsImUiLCJoIiwiYXhpc0FsaWduZWRCb3VuZGFyeUJveGVzIiwiYWJzIiwiZXZlcnkiLCJjYWxjdWxhdGVTdXBlcnBvc2l0aW9uIiwibiIsInIiLCJyYW5kb20iLCJjb2xsaXNpb25SYW5kb21uZXNzIiwiY29sbGlzaW9ucyIsImNhbGN1bGF0ZWNDb2xsaXNpb25zIiwiY29sbGlzaW9uc0xpc3QiLCJzb21lIiwibG9vcCIsImluSGFzaCIsInB1c2giLCJyZWR1Y2UiLCJhIiwiYyIsInVwZGF0ZSIsImNvbnN0cnVjdG9yIiwiYm9yZGVycyIsImluaXRhbENvbmRpdGlvbnNQcmVzZXRzTGliIiwicmFuZG9tSW5pdGlhbENvbmRpdGlvbnMiLCJib3hlcyIsIl8iLCJpbmRleCIsInVwZGF0ZVByZXNldHNMaWIiLCJkdmRBbmltYXRpb24iLCJkZWx0YVRpbWUiLCJ2ZWxvY2l0eSIsInBvc2l0aW9uIiwicG9zIiwiRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlRWxhc3RpY0NvbGxpc2lvbiIsInVzZUNvbnRleHQiLCJSZWFjdEVsYXN0aWNDb2xsaXNpb24iLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNvbmZpZyIsInByZXNldHMiLCJib3hlc1JlZnMiLCJ1c2VSZWYiLCJNYXAiLCJzZWxlY3RlZFByZXNldCIsInNldFNlbGVjdGVkUHJlc2V0IiwidXNlU3RhdGUiLCJzZWN0aW9uUmVjdFJlZiIsInNlY3Rpb25SZWN0IiwidXNlUmVjdCIsImVsYXN0aWNDb2xsaXNpb24iLCJhZGRCb3giLCJ1c2VDYWxsYmFjayIsInNsaWRlIiwiY3VycmVudCIsInNldCIsInJlbW92ZUJveCIsImRlbGV0ZSIsInVzZUVmZmVjdCIsInNlbGVjdGVkSUMiLCJzZWxlY3RlZFVwZGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJ2YWx1ZXMiLCJpc0VtcHR5QXJyYXkiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJpbnN0YW5jZXMiLCJ1c2VGcmFtZSIsImluc3RhbmNlIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIkNvbGxpc2lvbkJveCIsInByb3BzIiwib25EcmFnU3RvcCIsInNldFJlY3RSZWYiLCJlbGVtZW50UmVmIiwiYmluZCIsInVzZURyYWciLCJkb3duIiwibW92ZW1lbnQiLCJteCIsIm15IiwiX2V4dGVuZHMiLCJub2RlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs\n"));

/***/ })

});