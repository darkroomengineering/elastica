"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(pages)/home/page",{

/***/ "(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs":
/*!***********************************************************!*\
  !*** ../packages/react/dist/elastic-collisions-react.mjs ***!
  \***********************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionBox: function() { return /* binding */ CollisionBox; },\n/* harmony export */   \"default\": function() { return /* binding */ ReactElasticCollision; },\n/* harmony export */   dragForcePresetsLib: function() { return /* binding */ u; },\n/* harmony export */   initalConditionsPresets: function() { return /* binding */ l; },\n/* harmony export */   updatePresets: function() { return /* binding */ d; },\n/* harmony export */   useElasticCollision: function() { return /* binding */ useElasticCollision; }\n/* harmony export */ });\n/* harmony import */ var _darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @darkroom.engineering/hamo */ \"(app-pages-browser)/../node_modules/.pnpm/@darkroom.engineering+hamo@0.6.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@darkroom.engineering/hamo/dist/hamo.modern.mjs\");\n/* harmony import */ var _use_gesture_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/react */ \"(app-pages-browser)/../node_modules/.pnpm/@use-gesture+react@10.3.1_react@18.3.1/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.4_@babel+core@7.24.9_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.8/node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\n\n\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(i) {\n        for(var t = 1; t < arguments.length; t++){\n            var s = arguments[t];\n            for(var e in s)({}).hasOwnProperty.call(s, e) && (i[e] = s[e]);\n        }\n        return i;\n    }, _extends.apply(null, arguments);\n}\nclass ElasticCollision {\n    initialConditions(i, t) {\n        let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>{};\n        this.container = t, this.dimensions = i.map((i, t)=>{\n            if (!i) return [\n                0,\n                0\n            ];\n            this.externalForces[t] = [\n                0,\n                0\n            ];\n            const { rect: s } = i;\n            return [\n                s.width / 2,\n                s.height / 2\n            ];\n        }), s(this), this.positions.forEach((t, s)=>{\n            var _i_s;\n            this.hash[s] = Math.floor(this.gridSize * (t[0] / this.container.width)) + Math.floor(this.gridSize * (t[1] / this.container.height)) * this.gridSize, this.setPosition((_i_s = i[s]) === null || _i_s === void 0 ? void 0 : _i_s.element, {\n                x: t[0],\n                y: t[1]\n            });\n        });\n    }\n    polarCoordinates(i) {\n        return {\n            speed: Math.sqrt(i[0] * i[0] + i[1] * i[1]),\n            angle: Math.atan2(i[1], i[0])\n        };\n    }\n    cartesianCoordinates(i, t) {\n        return [\n            i * Math.cos(t),\n            i * Math.sin(t)\n        ];\n    }\n    hasBounced(i) {\n        return this.bounced[i] += 1;\n    }\n    setPosition(i, param) {\n        let { x: t = 0, y: s = 0, z: e = 0 } = param;\n        i && (i.style.cssText = \"transform: translate3d(\".concat(t, \"px, \").concat(s, \"px, \").concat(e, \"px);\"));\n    }\n    rigidBorders(i) {\n        if (\"rigid\" !== this.calculateBorders) return;\n        const t = this.containerOffsets.top, s = this.containerOffsets.left, e = this.containerOffsets.right + 1, o = this.containerOffsets.bottom + 1;\n        for(let n = 0; n < i.length; n++){\n            const i = this.dimensions[n];\n            let r = this.velocities[n], h = this.positions[n];\n            h[1] < i[1] + this.container.height * t && (this.hasBounced(n), this.velocities[n][1] = -r[1], this.positions[n][1] = i[1] + this.container.height * t), h[0] < i[0] + this.container.width * s && (this.hasBounced(n), this.velocities[n][0] = -r[0], this.positions[n][0] = i[0] + this.container.width * s), h[1] > this.container.height * o - i[1] && (this.hasBounced(n), this.velocities[n][1] = -r[1], this.positions[n][1] = this.container.height * o - i[1]), h[0] > this.container.width * e - i[0] && (this.hasBounced(n), this.velocities[n][0] = -r[0], this.positions[n][0] = this.container.width * e - i[0]);\n        }\n    }\n    periodicBorders(i) {\n        if (\"periodic\" !== this.calculateBorders) return;\n        const t = this.containerOffsets.top, s = this.containerOffsets.left, e = this.containerOffsets.right + 1, o = this.containerOffsets.bottom + 1;\n        for(let n = 0; n < i.length; n++){\n            const i = this.dimensions[n];\n            let r = this.positions[n], h = this.velocities[n].map((i)=>Math.sign(i));\n            -1 === h[1] && r[1] < i[1] + this.container.height * t && (this.positions[n][1] = i[1] + this.container.height * o), 1 === h[1] && r[1] > this.container.height * o - i[1] && (this.positions[n][1] = this.container.height * t - i[1]), -1 === h[0] && r[0] < i[0] + this.container.width * s && (this.positions[n][0] = i[0] + this.container.width * e), 1 === h[0] && r[0] > this.container.width * e - i[0] && (this.positions[n][0] = this.container.width * s - i[0]);\n        }\n    }\n    isNeighboor(i, t) {\n        const s = this.hash[t];\n        let e = this.hash[i], o = !1;\n        for(let i = -1; i < 2; i++)for(let t = -1; t < 2; t++){\n            let n = e + this.gridSize * i + t;\n            if (!(n < 0 || n > this.gridSize * this.gridSize) && n === s) {\n                o = !0;\n                break;\n            }\n        }\n        return o;\n    }\n    axisAlignedBoundaryBoxes(i, t) {\n        const s = this.dimensions[i], e = this.positions[i], o = this.dimensions[t], n = this.positions[t];\n        return e.map((i, t)=>Math.abs(i - n[t]) < s[t] + o[t]).every((i)=>i);\n    }\n    calculateSuperposition(i, t) {\n        let s = [\n            0,\n            0\n        ];\n        const e = this.positions[i], o = this.dimensions[i], n = this.positions[t], r = this.dimensions[t], h = e.map((i, t)=>o[t] + r[t] - Math.abs(i - n[t]));\n        return h[0] < h[1] ? e[0] < n[0] ? s[0] = h[0] : s[0] = -h[0] : e[1] < n[1] ? s[1] = h[1] : s[1] = -h[1], s.map((i)=>i + Math.random() * this.collisionRandomness);\n    }\n    collisions(i) {\n        if (this.calculatecCollisions) {\n            this.collisionsList = [];\n            for(let t = 0; t < i.length; t++){\n                let i = this.velocities[t];\n                this.hash.forEach((s, e)=>{\n                    if (e === t) return;\n                    let o = this.velocities[e];\n                    if (this.collisionsList.some((param)=>{\n                        let { loop: i, inHash: s } = param;\n                        return i === e && s === t;\n                    })) return;\n                    if (!this.isNeighboor(t, e)) return;\n                    if (!this.axisAlignedBoundaryBoxes(t, e)) return;\n                    this.collisionsList.push({\n                        loop: t,\n                        inHash: e\n                    });\n                    const n = .5 * (i.reduce((i, t)=>i + t * t, 0) + o.reduce((i, t)=>i + t * t, 0)), r = this.calculateSuperposition(t, e);\n                    let h = i.map((i, t)=>i + r[t]), a = o.map((i, t)=>i - r[t]);\n                    const c = .5 * (h.reduce((i, t)=>i + t * t, 0) + a.reduce((i, t)=>i + t * t, 0));\n                    if (0 !== c) {\n                        const i = Math.sqrt(n / c);\n                        h = h.map((t)=>t * i), a = a.map((t)=>t * i);\n                    }\n                    this.velocities[t] = a, this.velocities[e] = h;\n                });\n            }\n        }\n    }\n    update(i, t) {\n        this.rigidBorders(i), this.periodicBorders(i), this.collisions(i), t(this), this.positions.forEach((i, t)=>{\n            this.hash[t] = Math.floor(this.gridSize * i[0] / this.container.width) + Math.floor(this.gridSize * i[1] / this.container.height) * this.gridSize;\n        });\n    }\n    constructor({ gridSize: i = 4, containerOffsets: t = {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n    }, collisions: s = !0, borders: e = \"rigid\", collisionRandomness: o = 0 } = {}){\n        this.calculatecCollisions = s, this.calculateBorders = e, this.collisionRandomness = o, this.gridSize = i, this.containerOffsets = t, this.positions = [], this.velocities = [], this.externalForces = [], this.dimensions = [], this.bounced = [], this.hash = [], this.container = {}, this.collisionsList = [];\n    }\n}\nconst l = {\n    random: function randomInitialConditions(param) {\n        let { boxes: i, positions: t, velocities: s, container: e } = param;\n        i.forEach((i, o)=>{\n            t[o] = [\n                Math.random() * e.width,\n                Math.random() * e.height\n            ], s[o] = [\n                .5 * (Math.random() - .5),\n                .5 * (Math.random() - .5)\n            ];\n        });\n    }\n};\nconst d = {\n    dvdAnimation: function dvdAnimation(param) {\n        let { boxes: i, positions: t, velocities: s, deltaTime: e } = param;\n        i.forEach((i, o)=>{\n            t[o] = t[o].map((i, t)=>i + s[o][t] * e);\n        });\n    },\n    DragAndGravity: function DragAndGravity(param) {\n        let { boxes: i, positions: t, velocities: s, deltaTime: e, externalForces: o } = param;\n        i.forEach((i, n)=>{\n            let r = s[n], h = t[n], a = o[n];\n            const c = [\n                0,\n                -.1\n            ];\n            r = r.map((i, t)=>i + -.001 * e * (i - 4 * a[t] + c[t])), h = h.map((i, t)=>i + r[t] * e), t[n] = h, s[n] = r, o[n] = [\n                0,\n                0\n            ];\n        });\n    },\n    rightFlow: function rightFlow(param) {\n        let { boxes: i, positions: t, velocities: s, externalForces: e, deltaTime: o } = param;\n        i.forEach((i, n)=>{\n            let r = s[n], h = t[n], a = e[n];\n            const c = [\n                .25,\n                0\n            ];\n            r = r.map((i, t)=>i + -.001 * o * (i - 4 * a[t] + c[t])), t[n] = h = h.map((i, t)=>i + r[t] * o), t[n] = h, s[n] = r, e[n] = [\n                0,\n                0\n            ];\n        });\n    }\n};\nconst u = {\n    default: function dragForce(i, t, s) {\n        let e = i.map((i)=>i * i).reduce((i, t)=>i + t);\n        e = Math.sqrt(e), 0 !== e && (t[s] = i.map((i)=>i / e));\n    }\n};\nconst f = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useElasticCollision() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(f);\n}\nfunction ReactElasticCollision(param) {\n    let { children: s, className: o, config: c = {\n        gridSize: 8,\n        collisions: !0,\n        borders: \"rigid\",\n        containerOffsets: {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        }\n    }, initialConditions: l = ()=>{}, update: d = ()=>{} } = param;\n    const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map), [m, p] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), [g] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new ElasticCollision(c)), v = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((i, t)=>{\n        u.current.set(i, t);\n    }, []), x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((i)=>{\n        u.current.delete(i);\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const i = [\n            ...u.current.values()\n        ];\n        (function isEmptyArray(i) {\n            return !i || Array.isArray(i) && 0 === i.length;\n        })(i) || i.some((param)=>{\n            let { rect: i } = param;\n            return !i;\n        }) || g.initialConditions(i, p, (t)=>l({\n                boxes: i,\n                ...t\n            }));\n    }, [\n        g,\n        p\n    ]), (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useFrame)((i, t)=>{\n        const s = [\n            ...u.current.values()\n        ];\n        g.update(s, (i)=>{\n            d({\n                boxes: s,\n                ...i,\n                deltaTime: t\n            }), s.forEach((t, s)=>{\n                const e = i.positions[s], o = i.dimensions[s];\n                i === null || i === void 0 ? void 0 : i.setPosition(t === null || t === void 0 ? void 0 : t.element, {\n                    x: e[0] - o[0],\n                    y: e[1]\n                });\n            });\n        });\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: o,\n        ref: m,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(f.Provider, {\n        value: {\n            addBox: v,\n            removeBox: x,\n            elasticCollision: g\n        }\n    }, s));\n}\n_c = ReactElasticCollision;\nfunction CollisionBox(param) {\n    let { className: t, children: o, onDragStop: r = null, index: h = 0, ...c } = param;\n    _s();\n    const { addBox: l, removeBox: d, elasticCollision: u } = useElasticCollision(), [f, m] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (p.current) return l(p.current, {\n            element: p.current,\n            rect: m\n        }), ()=>{\n            d(p.current);\n        };\n    }, [\n        m,\n        l,\n        d\n    ]);\n    const g = (0,_use_gesture_react__WEBPACK_IMPORTED_MODULE_2__.useDrag)((param)=>{\n        let { down: i, movement: [t, s] } = param;\n        i && r([\n            t,\n            s\n        ], u.externalForces, h);\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: (i)=>{\n            p.current = i, f(i);\n        },\n        className: t,\n        style: {\n            touchAction: \"none\"\n        }\n    }, c), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", g(), o));\n}\n_s(CollisionBox, \"btanLGYeOd65KmA2Ov2a1xBJhTk=\", false, function() {\n    return [\n        useElasticCollision,\n        useElasticCollision,\n        useElasticCollision\n    ];\n});\n_c1 = CollisionBox;\n //# sourceMappingURL=elastic-collisions-react.mjs.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ReactElasticCollision\");\n$RefreshReg$(_c1, \"CollisionBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9wYWNrYWdlcy9yZWFjdC9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BO0lBQXlhQyxrQkFBa0JDLENBQUFBLEVBQUVDLENBQUFBLEVBQUk7WUFBRkMsSUFBQUEsaUVBQUU7UUFBUUMsSUFBQUEsQ0FBS0MsU0FBQUEsR0FBVUgsR0FBRUUsSUFBQUEsQ0FBS0UsVUFBQUEsR0FBV0wsRUFBRU0sR0FBQUEsQ0FBSyxDQUFDTixHQUFFQztZQUFLLEtBQUlELEdBQUUsT0FBTTtnQkFBQztnQkFBRTthQUFBO1lBQUdHLElBQUFBLENBQUtJLGNBQUFBLENBQWVOLEVBQUFBLEdBQUc7Z0JBQUM7Z0JBQUU7YUFBQTtZQUFHLFFBQU1PLE1BQUtOLENBQUFBLEVBQUFBLEdBQUdGO1lBQUUsT0FBTTtnQkFBQ0UsRUFBRU8sS0FBQUEsR0FBTTtnQkFBRVAsRUFBRVEsTUFBQUEsR0FBTzthQUFHO1FBQUEsSUFBR1IsRUFBRUMsSUFBQUEsR0FBTUEsSUFBQUEsQ0FBS1EsU0FBQUEsQ0FBVUMsT0FBQUEsQ0FBTyxDQUFHWCxHQUFFQztnQkFBOEpGO1lBQXpKRyxJQUFBQSxDQUFLVSxJQUFBQSxDQUFLWCxFQUFBQSxHQUFHWSxLQUFLQyxLQUFBQSxDQUFNWixJQUFBQSxDQUFLYSxRQUFBQSxHQUFVZixDQUFBQSxDQUFBQSxDQUFFLEtBQUdFLElBQUFBLENBQUtDLFNBQUFBLENBQVVLLEtBQUFBLEtBQVFLLEtBQUtDLEtBQUFBLENBQU1aLElBQUFBLENBQUthLFFBQUFBLEdBQVVmLENBQUFBLENBQUFBLENBQUUsS0FBR0UsSUFBQUEsQ0FBS0MsU0FBQUEsQ0FBVU0sTUFBQUEsS0FBU1AsSUFBQUEsQ0FBS2EsUUFBQUEsRUFBU2IsSUFBQUEsQ0FBS2MsV0FBQUEsRUFBWWpCLE9BQUFBLENBQUFBLENBQUVFLEVBQUFBLGNBQUZGLDJCQUFBQSxLQUFN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QUFBQSxFQUFnQm1FO0lBQ3hEO0lBR0YscUJBQ0VrRCxnREFBQUMsQ0FBQSxPQUFBZSxTQUFBO1FBQ0VkLEtBQU1lLENBQUFBO1lBQ0pSLEVBQVd0QixPQUFBQSxHQUFVOEIsR0FDckJULEVBQVdTO1FBQUs7UUFFbEIzQyxXQUFXQTtRQUNYakUsT0FBTztZQUFFNkcsYUFBYTtRQUFBO0lBQUEsR0FDbEJaLGtCQUVKTixnREFBQUMsQ0FBQSxPQUFTUyxLQUFTckM7QUFHeEI7R0EzQ1NnQzs7UUFPeUNuQztRQUFBQTtRQUFBQTs7O01BUHpDbUM7QUEyQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2VuZ2luZS9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy5tanM/NDA5MCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9wcmVzZXRzLmpzP2FjMDIiLCJ3ZWJwYWNrOi8vX05fRS8uLi9zcmMvaW5kZXguanM/NWE2MCIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy91dGlscy5qcz9hY2UwIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEVsYXN0aWNDb2xsaXNpb257Y29uc3RydWN0b3Ioe2dyaWRTaXplOmk9NCxjb250YWluZXJPZmZzZXRzOnQ9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowfSxjb2xsaXNpb25zOnM9ITAsYm9yZGVyczpvPVwicmlnaWRcIixjb2xsaXNpb25SYW5kb21uZXNzOmU9MH09e30pe3RoaXMuY2FsY3VsYXRlY0NvbGxpc2lvbnM9cyx0aGlzLmNhbGN1bGF0ZUJvcmRlcnM9byx0aGlzLmNvbGxpc2lvblJhbmRvbW5lc3M9ZSx0aGlzLmdyaWRTaXplPWksdGhpcy5jb250YWluZXJPZmZzZXRzPXQsdGhpcy5wb3NpdGlvbnM9W10sdGhpcy52ZWxvY2l0aWVzPVtdLHRoaXMuZXh0ZXJuYWxGb3JjZXM9W10sdGhpcy5kaW1lbnNpb25zPVtdLHRoaXMuYm91bmNlZD1bXSx0aGlzLmhhc2g9W10sdGhpcy5jb250YWluZXI9e30sdGhpcy5jb2xsaXNpb25zTGlzdD1bXX1pbml0aWFsQ29uZGl0aW9ucyhpLHQscz0oKT0+e30pe3RoaXMuY29udGFpbmVyPXQsdGhpcy5kaW1lbnNpb25zPWkubWFwKCgoaSx0KT0+e2lmKCFpKXJldHVyblswLDBdO3RoaXMuZXh0ZXJuYWxGb3JjZXNbdF09WzAsMF07Y29uc3R7cmVjdDpzfT1pO3JldHVybltzLndpZHRoLzIscy5oZWlnaHQvMl19KSkscyh0aGlzKSx0aGlzLnBvc2l0aW9ucy5mb3JFYWNoKCgodCxzKT0+e3RoaXMuaGFzaFtzXT1NYXRoLmZsb29yKHRoaXMuZ3JpZFNpemUqKHRbMF0vdGhpcy5jb250YWluZXIud2lkdGgpKStNYXRoLmZsb29yKHRoaXMuZ3JpZFNpemUqKHRbMV0vdGhpcy5jb250YWluZXIuaGVpZ2h0KSkqdGhpcy5ncmlkU2l6ZSx0aGlzLnNldFBvc2l0aW9uKGlbc10/LmVsZW1lbnQse3g6dFswXSx5OnRbMV19KX0pKX1wb2xhckNvb3JkaW5hdGVzKGkpe3JldHVybntzcGVlZDpNYXRoLnNxcnQoaVswXSppWzBdK2lbMV0qaVsxXSksYW5nbGU6TWF0aC5hdGFuMihpWzFdLGlbMF0pfX1jYXJ0ZXNpYW5Db29yZGluYXRlcyhpLHQpe3JldHVybltpKk1hdGguY29zKHQpLGkqTWF0aC5zaW4odCldfWhhc0JvdW5jZWQoaSl7cmV0dXJuIHRoaXMuYm91bmNlZFtpXSs9MX1zZXRQb3NpdGlvbihpLHt4OnQ9MCx5OnM9MCx6Om89MH0pe2kmJihpLnN0eWxlLmNzc1RleHQ9YHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJHt0fXB4LCAke3N9cHgsICR7b31weCk7YCl9cmlnaWRCb3JkZXJzKGkpe2lmKFwicmlnaWRcIiE9PXRoaXMuY2FsY3VsYXRlQm9yZGVycylyZXR1cm47Y29uc3QgdD10aGlzLmNvbnRhaW5lck9mZnNldHMudG9wLHM9dGhpcy5jb250YWluZXJPZmZzZXRzLmxlZnQsbz10aGlzLmNvbnRhaW5lck9mZnNldHMucmlnaHQrMSxlPXRoaXMuY29udGFpbmVyT2Zmc2V0cy5ib3R0b20rMTtmb3IobGV0IGg9MDtoPGkubGVuZ3RoO2grKyl7Y29uc3QgaT10aGlzLmRpbWVuc2lvbnNbaF07bGV0IG49dGhpcy52ZWxvY2l0aWVzW2hdLHI9dGhpcy5wb3NpdGlvbnNbaF07clsxXTxpWzFdK3RoaXMuY29udGFpbmVyLmhlaWdodCp0JiYodGhpcy5oYXNCb3VuY2VkKGgpLHRoaXMudmVsb2NpdGllc1toXVsxXT0tblsxXSx0aGlzLnBvc2l0aW9uc1toXVsxXT1pWzFdK3RoaXMuY29udGFpbmVyLmhlaWdodCp0KSxyWzBdPGlbMF0rdGhpcy5jb250YWluZXIud2lkdGgqcyYmKHRoaXMuaGFzQm91bmNlZChoKSx0aGlzLnZlbG9jaXRpZXNbaF1bMF09LW5bMF0sdGhpcy5wb3NpdGlvbnNbaF1bMF09aVswXSt0aGlzLmNvbnRhaW5lci53aWR0aCpzKSxyWzFdPnRoaXMuY29udGFpbmVyLmhlaWdodCplLWlbMV0mJih0aGlzLmhhc0JvdW5jZWQoaCksdGhpcy52ZWxvY2l0aWVzW2hdWzFdPS1uWzFdLHRoaXMucG9zaXRpb25zW2hdWzFdPXRoaXMuY29udGFpbmVyLmhlaWdodCplLWlbMV0pLHJbMF0+dGhpcy5jb250YWluZXIud2lkdGgqby1pWzBdJiYodGhpcy5oYXNCb3VuY2VkKGgpLHRoaXMudmVsb2NpdGllc1toXVswXT0tblswXSx0aGlzLnBvc2l0aW9uc1toXVswXT10aGlzLmNvbnRhaW5lci53aWR0aCpvLWlbMF0pfX1wZXJpb2RpY0JvcmRlcnMoaSl7aWYoXCJwZXJpb2RpY1wiIT09dGhpcy5jYWxjdWxhdGVCb3JkZXJzKXJldHVybjtjb25zdCB0PXRoaXMuY29udGFpbmVyT2Zmc2V0cy50b3Ascz10aGlzLmNvbnRhaW5lck9mZnNldHMubGVmdCxvPXRoaXMuY29udGFpbmVyT2Zmc2V0cy5yaWdodCsxLGU9dGhpcy5jb250YWluZXJPZmZzZXRzLmJvdHRvbSsxO2ZvcihsZXQgaD0wO2g8aS5sZW5ndGg7aCsrKXtjb25zdCBpPXRoaXMuZGltZW5zaW9uc1toXTtsZXQgbj10aGlzLnBvc2l0aW9uc1toXSxyPXRoaXMudmVsb2NpdGllc1toXS5tYXAoKGk9Pk1hdGguc2lnbihpKSkpOy0xPT09clsxXSYmblsxXTxpWzFdK3RoaXMuY29udGFpbmVyLmhlaWdodCp0JiYodGhpcy5wb3NpdGlvbnNbaF1bMV09aVsxXSt0aGlzLmNvbnRhaW5lci5oZWlnaHQqZSksMT09PXJbMV0mJm5bMV0+dGhpcy5jb250YWluZXIuaGVpZ2h0KmUtaVsxXSYmKHRoaXMucG9zaXRpb25zW2hdWzFdPXRoaXMuY29udGFpbmVyLmhlaWdodCp0LWlbMV0pLC0xPT09clswXSYmblswXTxpWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnMmJih0aGlzLnBvc2l0aW9uc1toXVswXT1pWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKm8pLDE9PT1yWzBdJiZuWzBdPnRoaXMuY29udGFpbmVyLndpZHRoKm8taVswXSYmKHRoaXMucG9zaXRpb25zW2hdWzBdPXRoaXMuY29udGFpbmVyLndpZHRoKnMtaVswXSl9fWlzTmVpZ2hib29yKGksdCl7Y29uc3Qgcz10aGlzLmhhc2hbdF07bGV0IG89dGhpcy5oYXNoW2ldLGU9ITE7Zm9yKGxldCBpPS0xO2k8MjtpKyspZm9yKGxldCB0PS0xO3Q8Mjt0Kyspe2xldCBoPW8rdGhpcy5ncmlkU2l6ZSppK3Q7aWYoIShoPDB8fGg+dGhpcy5ncmlkU2l6ZSp0aGlzLmdyaWRTaXplKSYmaD09PXMpe2U9ITA7YnJlYWt9fXJldHVybiBlfWF4aXNBbGlnbmVkQm91bmRhcnlCb3hlcyhpLHQpe2NvbnN0IHM9dGhpcy5kaW1lbnNpb25zW2ldLG89dGhpcy5wb3NpdGlvbnNbaV0sZT10aGlzLmRpbWVuc2lvbnNbdF0saD10aGlzLnBvc2l0aW9uc1t0XTtyZXR1cm4gby5tYXAoKChpLHQpPT5NYXRoLmFicyhpLWhbdF0pPHNbdF0rZVt0XSkpLmV2ZXJ5KChpPT5pKSl9Y2FsY3VsYXRlU3VwZXJwb3NpdGlvbihpLHQpe2xldCBzPVswLDBdO2NvbnN0IG89dGhpcy5wb3NpdGlvbnNbaV0sZT10aGlzLmRpbWVuc2lvbnNbaV0saD10aGlzLnBvc2l0aW9uc1t0XSxuPXRoaXMuZGltZW5zaW9uc1t0XSxyPW8ubWFwKCgoaSx0KT0+ZVt0XStuW3RdLU1hdGguYWJzKGktaFt0XSkpKTtyZXR1cm4gclswXTxyWzFdP29bMF08aFswXT9zWzBdPXJbMF06c1swXT0tclswXTpvWzFdPGhbMV0/c1sxXT1yWzFdOnNbMV09LXJbMV0scy5tYXAoKGk9PmkrTWF0aC5yYW5kb20oKSp0aGlzLmNvbGxpc2lvblJhbmRvbW5lc3MpKX1jb2xsaXNpb25zKGkpe2lmKHRoaXMuY2FsY3VsYXRlY0NvbGxpc2lvbnMpe3RoaXMuY29sbGlzaW9uc0xpc3Q9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2xldCBpPXRoaXMudmVsb2NpdGllc1t0XTt0aGlzLmhhc2guZm9yRWFjaCgoKHMsbyk9PntpZihvPT09dClyZXR1cm47bGV0IGU9dGhpcy52ZWxvY2l0aWVzW29dO2lmKHRoaXMuY29sbGlzaW9uc0xpc3Quc29tZSgoKHtsb29wOmksaW5IYXNoOnN9KT0+aT09PW8mJnM9PT10KSkpcmV0dXJuO2lmKCF0aGlzLmlzTmVpZ2hib29yKHQsbykpcmV0dXJuO2lmKCF0aGlzLmF4aXNBbGlnbmVkQm91bmRhcnlCb3hlcyh0LG8pKXJldHVybjt0aGlzLmNvbGxpc2lvbnNMaXN0LnB1c2goe2xvb3A6dCxpbkhhc2g6b30pO2NvbnN0IGg9LjUqKGkucmVkdWNlKCgoaSx0KT0+aSt0KnQpLDApK2UucmVkdWNlKCgoaSx0KT0+aSt0KnQpLDApKSxuPXRoaXMuY2FsY3VsYXRlU3VwZXJwb3NpdGlvbih0LG8pO2xldCByPWkubWFwKCgoaSx0KT0+aStuW3RdKSksYT1lLm1hcCgoKGksdCk9Pmktblt0XSkpO2NvbnN0IGM9LjUqKHIucmVkdWNlKCgoaSx0KT0+aSt0KnQpLDApK2EucmVkdWNlKCgoaSx0KT0+aSt0KnQpLDApKTtpZigwIT09Yyl7Y29uc3QgaT1NYXRoLnNxcnQoaC9jKTtyPXIubWFwKCh0PT50KmkpKSxhPWEubWFwKCh0PT50KmkpKX10aGlzLnZlbG9jaXRpZXNbdF09YSx0aGlzLnZlbG9jaXRpZXNbb109cn0pKX19fXVwZGF0ZShpLHQpe3RoaXMucmlnaWRCb3JkZXJzKGkpLHRoaXMucGVyaW9kaWNCb3JkZXJzKGkpLHRoaXMuY29sbGlzaW9ucyhpKSx0KHRoaXMpLHRoaXMucG9zaXRpb25zLmZvckVhY2goKChpLHQpPT57dGhpcy5oYXNoW3RdPU1hdGguZmxvb3IodGhpcy5ncmlkU2l6ZSppWzBdL3RoaXMuY29udGFpbmVyLndpZHRoKStNYXRoLmZsb29yKHRoaXMuZ3JpZFNpemUqaVsxXS90aGlzLmNvbnRhaW5lci5oZWlnaHQpKnRoaXMuZ3JpZFNpemV9KSl9fWV4cG9ydHtFbGFzdGljQ29sbGlzaW9uIGFzIGRlZmF1bHR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxhc3RpYy1jb2xsaXNpb25zLm1qcy5tYXBcbiIsImZ1bmN0aW9uIHJhbmRvbUluaXRpYWxDb25kaXRpb25zKHsgYm94ZXMsIHBvc2l0aW9ucywgdmVsb2NpdGllcywgY29udGFpbmVyIH0pIHtcbiAgYm94ZXMuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICBwb3NpdGlvbnNbaW5kZXhdID0gW1xuICAgICAgTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci53aWR0aCxcbiAgICAgIE1hdGgucmFuZG9tKCkgKiBjb250YWluZXIuaGVpZ2h0LFxuICAgIF1cbiAgICB2ZWxvY2l0aWVzW2luZGV4XSA9IFtcbiAgICAgIDAuNSAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSxcbiAgICAgIDAuNSAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSxcbiAgICBdXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBpbml0YWxDb25kaXRpb25zUHJlc2V0cyA9IHtcbiAgcmFuZG9tOiByYW5kb21Jbml0aWFsQ29uZGl0aW9ucyxcbn1cblxuZnVuY3Rpb24gZHZkQW5pbWF0aW9uKHsgYm94ZXMsIHBvc2l0aW9ucywgdmVsb2NpdGllcywgZGVsdGFUaW1lIH0pIHtcbiAgYm94ZXMuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICBwb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb25zW2luZGV4XS5tYXAoXG4gICAgICAocG9zLCBpKSA9PiBwb3MgKyB2ZWxvY2l0aWVzW2luZGV4XVtpXSAqIGRlbHRhVGltZVxuICAgIClcbiAgfSlcbn1cblxuZnVuY3Rpb24gRHJhZ0FuZEdyYXZpdHkoe1xuICBib3hlcyxcbiAgcG9zaXRpb25zLFxuICB2ZWxvY2l0aWVzLFxuICBkZWx0YVRpbWUsXG4gIGV4dGVybmFsRm9yY2VzLFxufSkge1xuICBib3hlcy5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgIGxldCB2ZWxvY2l0eSA9IHZlbG9jaXRpZXNbaW5kZXhdXG4gICAgbGV0IHBvc2l0aW9uID0gcG9zaXRpb25zW2luZGV4XVxuICAgIGxldCBkcmFnZ2luID0gZXh0ZXJuYWxGb3JjZXNbaW5kZXhdXG4gICAgY29uc3QgZmxvdyA9IFswLCAtMC4xXVxuXG4gICAgdmVsb2NpdHkgPSB2ZWxvY2l0eS5tYXAoXG4gICAgICAodiwgaSkgPT4gdiArIGRlbHRhVGltZSAqIC0wLjAwMSAqICh2IC0gNCAqIGRyYWdnaW5baV0gKyBmbG93W2ldKVxuICAgIClcblxuICAgIHBvc2l0aW9uID0gcG9zaXRpb24ubWFwKChwb3MsIGkpID0+IHBvcyArIHZlbG9jaXR5W2ldICogZGVsdGFUaW1lKVxuXG4gICAgcG9zaXRpb25zW2luZGV4XSA9IHBvc2l0aW9uXG4gICAgdmVsb2NpdGllc1tpbmRleF0gPSB2ZWxvY2l0eVxuXG4gICAgZXh0ZXJuYWxGb3JjZXNbaW5kZXhdID0gWzAsIDBdXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJpZ2h0Rmxvdyh7XG4gIGJveGVzLFxuICBwb3NpdGlvbnMsXG4gIHZlbG9jaXRpZXMsXG4gIGV4dGVybmFsRm9yY2VzLFxuICBkZWx0YVRpbWUsXG59KSB7XG4gIGJveGVzLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgbGV0IHZlbG9jaXR5ID0gdmVsb2NpdGllc1tpbmRleF1cbiAgICBsZXQgcG9zaXRpb24gPSBwb3NpdGlvbnNbaW5kZXhdXG4gICAgbGV0IGRyYWdnaW4gPSBleHRlcm5hbEZvcmNlc1tpbmRleF1cbiAgICBjb25zdCBmbG93ID0gWzAuMjUsIDBdXG5cbiAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5Lm1hcChcbiAgICAgICh2LCBpKSA9PiB2ICsgZGVsdGFUaW1lICogLTAuMDAxICogKHYgLSA0ICogZHJhZ2dpbltpXSArIGZsb3dbaV0pXG4gICAgKVxuXG4gICAgcG9zaXRpb25zW2luZGV4XSA9IHBvc2l0aW9uID0gcG9zaXRpb24ubWFwKFxuICAgICAgKHBvcywgaSkgPT4gcG9zICsgdmVsb2NpdHlbaV0gKiBkZWx0YVRpbWVcbiAgICApXG5cbiAgICBwb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb25cbiAgICB2ZWxvY2l0aWVzW2luZGV4XSA9IHZlbG9jaXR5XG5cbiAgICBleHRlcm5hbEZvcmNlc1tpbmRleF0gPSBbMCwgMF1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByZXNldHMgPSB7XG4gIGR2ZEFuaW1hdGlvbixcbiAgRHJhZ0FuZEdyYXZpdHksXG4gIHJpZ2h0Rmxvdyxcbn1cblxuZnVuY3Rpb24gZHJhZ0ZvcmNlKG5ld0RpciwgZXh0ZXJuYWxGb3JjZXMsIGluZGV4KSB7XG4gIGxldCBub3JtID0gbmV3RGlyLm1hcCgocG9zKSA9PiBwb3MgKiBwb3MpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gIG5vcm0gPSBNYXRoLnNxcnQobm9ybSlcblxuICBpZiAobm9ybSA9PT0gMCkgcmV0dXJuXG4gIGV4dGVybmFsRm9yY2VzW2luZGV4XSA9IG5ld0Rpci5tYXAoKHBvcykgPT4gcG9zIC8gbm9ybSlcbn1cblxuZXhwb3J0IGNvbnN0IGRyYWdGb3JjZVByZXNldHNMaWIgPSB7XG4gIGRlZmF1bHQ6IGRyYWdGb3JjZSxcbn1cbiIsImltcG9ydCB7IHVzZUZyYW1lLCB1c2VSZWN0IH0gZnJvbSAnQGRhcmtyb29tLmVuZ2luZWVyaW5nL2hhbW8nXG5pbXBvcnQgeyB1c2VEcmFnIH0gZnJvbSAnQHVzZS1nZXN0dXJlL3JlYWN0J1xuaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEVsYXN0aWNDb2xsaXNpb24gZnJvbSAnLi4vLi4vZW5naW5lL2Rpc3QvZWxhc3RpYy1jb2xsaXNpb25zLm1qcydcbmltcG9ydCB7XG4gIGRyYWdGb3JjZVByZXNldHNMaWIsXG4gIGluaXRhbENvbmRpdGlvbnNQcmVzZXRzLFxuICB1cGRhdGVQcmVzZXRzLFxufSBmcm9tICcuL3ByZXNldHMnXG5pbXBvcnQgeyBpc0VtcHR5QXJyYXkgfSBmcm9tICcuL3V0aWxzJ1xuXG5jb25zdCBFbGFzdGljQ29sbGlzaW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pXG5cbmZ1bmN0aW9uIHVzZUVsYXN0aWNDb2xsaXNpb24oKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KEVsYXN0aWNDb2xsaXNpb25Db250ZXh0KVxufVxuXG5mdW5jdGlvbiBSZWFjdEVsYXN0aWNDb2xsaXNpb24oe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICBjb25maWcgPSB7XG4gICAgZ3JpZFNpemU6IDgsXG4gICAgY29sbGlzaW9uczogdHJ1ZSxcbiAgICBib3JkZXJzOiAncmlnaWQnLFxuICAgIGNvbnRhaW5lck9mZnNldHM6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICB9LFxuICB9LFxuICBpbml0aWFsQ29uZGl0aW9ucyA9ICgpID0+IHt9LFxuICB1cGRhdGUgPSAoKSA9PiB7fSxcbn0pIHtcbiAgY29uc3QgYm94ZXNSZWZzID0gdXNlUmVmKG5ldyBNYXAoKSlcbiAgY29uc3QgW3NlY3Rpb25SZWN0UmVmLCBzZWN0aW9uUmVjdF0gPSB1c2VSZWN0KClcbiAgY29uc3QgW2VsYXN0aWNDb2xsaXNpb25dID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVsYXN0aWNDb2xsaXNpb24oY29uZmlnKSlcblxuICBjb25zdCBhZGRCb3ggPSB1c2VDYWxsYmFjaygoZWxlbWVudCwgc2xpZGUpID0+IHtcbiAgICBib3hlc1JlZnMuY3VycmVudC5zZXQoZWxlbWVudCwgc2xpZGUpXG4gIH0sIFtdKVxuICBjb25zdCByZW1vdmVCb3ggPSB1c2VDYWxsYmFjaygoZWxlbWVudCkgPT4ge1xuICAgIGJveGVzUmVmcy5jdXJyZW50LmRlbGV0ZShlbGVtZW50KVxuICB9LCBbXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGJveGVzID0gWy4uLmJveGVzUmVmcy5jdXJyZW50LnZhbHVlcygpXVxuXG4gICAgaWYgKGlzRW1wdHlBcnJheShib3hlcykgfHwgYm94ZXMuc29tZSgoeyByZWN0IH0pID0+ICFyZWN0KSkgcmV0dXJuXG5cbiAgICBlbGFzdGljQ29sbGlzaW9uLmluaXRpYWxDb25kaXRpb25zKGJveGVzLCBzZWN0aW9uUmVjdCwgKGluc3RhbmNlcykgPT5cbiAgICAgIGluaXRpYWxDb25kaXRpb25zKHsgYm94ZXMsIC4uLmluc3RhbmNlcyB9KVxuICAgIClcbiAgfSwgW2VsYXN0aWNDb2xsaXNpb24sIHNlY3Rpb25SZWN0XSlcblxuICB1c2VGcmFtZSgoXywgZGVsdGFUaW1lKSA9PiB7XG4gICAgY29uc3QgYm94ZXMgPSBbLi4uYm94ZXNSZWZzLmN1cnJlbnQudmFsdWVzKCldXG5cbiAgICBlbGFzdGljQ29sbGlzaW9uLnVwZGF0ZShib3hlcywgKGluc3RhbmNlKSA9PiB7XG4gICAgICB1cGRhdGUoeyBib3hlcywgLi4uaW5zdGFuY2UsIGRlbHRhVGltZSB9KVxuXG4gICAgICBib3hlcy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGluc3RhbmNlLnBvc2l0aW9uc1tpbmRleF1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGluc3RhbmNlLmRpbWVuc2lvbnNbaW5kZXhdXG5cbiAgICAgICAgaW5zdGFuY2U/LnNldFBvc2l0aW9uKGVsZW1lbnQ/LmVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBzaGlmdCBjZW50ZXJzIGVsZW1lbnQgdG8gY2VudGVyIG9mIG1hc3NcbiAgICAgICAgICB4OiBwb3NpdGlvblswXSAtIGRpbWVuc2lvbnNbMF0sXG4gICAgICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgIHJlZj17c2VjdGlvblJlY3RSZWZ9XG4gICAgICBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX1cbiAgICA+XG4gICAgICA8RWxhc3RpY0NvbGxpc2lvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgdmFsdWU9e3sgYWRkQm94LCByZW1vdmVCb3gsIGVsYXN0aWNDb2xsaXNpb24gfX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9FbGFzdGljQ29sbGlzaW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBDb2xsaXNpb25Cb3goe1xuICBjbGFzc05hbWUsXG4gIGNoaWxkcmVuLFxuICBvbkRyYWdTdG9wID0gbnVsbCxcbiAgaW5kZXggPSAwLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IGFkZEJveCwgcmVtb3ZlQm94LCBlbGFzdGljQ29sbGlzaW9uIH0gPSB1c2VFbGFzdGljQ29sbGlzaW9uKClcbiAgY29uc3QgW3NldFJlY3RSZWYsIHJlY3RdID0gdXNlUmVjdCgpXG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgYWRkQm94KGVsZW1lbnRSZWYuY3VycmVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50UmVmLmN1cnJlbnQsXG4gICAgICAgIHJlY3QsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZW1vdmVCb3goZWxlbWVudFJlZi5jdXJyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlY3QsIGFkZEJveCwgcmVtb3ZlQm94XSlcblxuICBjb25zdCBiaW5kID0gdXNlRHJhZygoeyBkb3duLCBtb3ZlbWVudDogW214LCBteV0gfSkgPT4ge1xuICAgIGlmIChkb3duKSB7XG4gICAgICBvbkRyYWdTdG9wKFtteCwgbXldLCBlbGFzdGljQ29sbGlzaW9uLmV4dGVybmFsRm9yY2VzLCBpbmRleClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9eyhub2RlKSA9PiB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG5vZGVcbiAgICAgICAgc2V0UmVjdFJlZihub2RlKVxuICAgICAgfX1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgc3R5bGU9e3sgdG91Y2hBY3Rpb246ICdub25lJyB9fVxuICAgICAgey4uLnByb3BzfVxuICAgID5cbiAgICAgIDxkaXYgey4uLmJpbmQoKX0+e2NoaWxkcmVufTwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0RWxhc3RpY0NvbGxpc2lvblxuZXhwb3J0IHtcbiAgQ29sbGlzaW9uQm94LFxuICBkcmFnRm9yY2VQcmVzZXRzTGliLFxuICBpbml0YWxDb25kaXRpb25zUHJlc2V0cyxcbiAgdXBkYXRlUHJlc2V0cyxcbiAgdXNlRWxhc3RpY0NvbGxpc2lvbixcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5QXJyYXkoYXJyKSB7XG4gIGlmICghYXJyKSByZXR1cm4gdHJ1ZVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA9PT0gMFxufVxuIl0sIm5hbWVzIjpbIkVsYXN0aWNDb2xsaXNpb24iLCJpbml0aWFsQ29uZGl0aW9ucyIsImkiLCJ0IiwicyIsInRoaXMiLCJjb250YWluZXIiLCJkaW1lbnNpb25zIiwibWFwIiwiZXh0ZXJuYWxGb3JjZXMiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbnMiLCJmb3JFYWNoIiwiaGFzaCIsIk1hdGgiLCJmbG9vciIsImdyaWRTaXplIiwic2V0UG9zaXRpb24iLCJlbGVtZW50IiwieCIsInkiLCJwb2xhckNvb3JkaW5hdGVzIiwic3BlZWQiLCJzcXJ0IiwiYW5nbGUiLCJhdGFuMiIsImNhcnRlc2lhbkNvb3JkaW5hdGVzIiwiY29zIiwic2luIiwiaGFzQm91bmNlZCIsImJvdW5jZWQiLCJ6IiwibyIsInN0eWxlIiwiY3NzVGV4dCIsInJpZ2lkQm9yZGVycyIsImNhbGN1bGF0ZUJvcmRlcnMiLCJjb250YWluZXJPZmZzZXRzIiwidG9wIiwibGVmdCIsInJpZ2h0IiwiZSIsImJvdHRvbSIsImgiLCJsZW5ndGgiLCJuIiwidmVsb2NpdGllcyIsInIiLCJwZXJpb2RpY0JvcmRlcnMiLCJzaWduIiwiaXNOZWlnaGJvb3IiLCJheGlzQWxpZ25lZEJvdW5kYXJ5Qm94ZXMiLCJhYnMiLCJldmVyeSIsImNhbGN1bGF0ZVN1cGVycG9zaXRpb24iLCJyYW5kb20iLCJjb2xsaXNpb25SYW5kb21uZXNzIiwiY29sbGlzaW9ucyIsImNhbGN1bGF0ZWNDb2xsaXNpb25zIiwiY29sbGlzaW9uc0xpc3QiLCJzb21lIiwibG9vcCIsImluSGFzaCIsInB1c2giLCJyZWR1Y2UiLCJhIiwiYyIsInVwZGF0ZSIsImNvbnN0cnVjdG9yIiwiYm9yZGVycyIsImluaXRhbENvbmRpdGlvbnNQcmVzZXRzIiwicmFuZG9tSW5pdGlhbENvbmRpdGlvbnMiLCJib3hlcyIsIl8iLCJpbmRleCIsInVwZGF0ZVByZXNldHMiLCJkdmRBbmltYXRpb24iLCJkZWx0YVRpbWUiLCJwb3MiLCJEcmFnQW5kR3Jhdml0eSIsInZlbG9jaXR5IiwicG9zaXRpb24iLCJkcmFnZ2luIiwiZmxvdyIsInYiLCJyaWdodEZsb3ciLCJkcmFnRm9yY2VQcmVzZXRzTGliIiwiZGVmYXVsdCIsImRyYWdGb3JjZSIsIm5ld0RpciIsIm5vcm0iLCJiIiwiRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlRWxhc3RpY0NvbGxpc2lvbiIsInVzZUNvbnRleHQiLCJSZWFjdEVsYXN0aWNDb2xsaXNpb24iLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNvbmZpZyIsImJveGVzUmVmcyIsInVzZVJlZiIsIk1hcCIsInNlY3Rpb25SZWN0UmVmIiwic2VjdGlvblJlY3QiLCJ1c2VSZWN0IiwiZWxhc3RpY0NvbGxpc2lvbiIsInVzZVN0YXRlIiwiYWRkQm94IiwidXNlQ2FsbGJhY2siLCJzbGlkZSIsImN1cnJlbnQiLCJzZXQiLCJyZW1vdmVCb3giLCJkZWxldGUiLCJ1c2VFZmZlY3QiLCJ2YWx1ZXMiLCJpc0VtcHR5QXJyYXkiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJpbnN0YW5jZXMiLCJ1c2VGcmFtZSIsImluc3RhbmNlIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIkNvbGxpc2lvbkJveCIsInByb3BzIiwib25EcmFnU3RvcCIsInNldFJlY3RSZWYiLCJlbGVtZW50UmVmIiwiYmluZCIsInVzZURyYWciLCJkb3duIiwibW92ZW1lbnQiLCJteCIsIm15IiwiX2V4dGVuZHMiLCJub2RlIiwidG91Y2hBY3Rpb24iLCJ1IiwibCIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs\n"));

/***/ })

});