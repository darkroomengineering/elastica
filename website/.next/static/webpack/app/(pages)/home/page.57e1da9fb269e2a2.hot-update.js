"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(pages)/home/page",{

/***/ "(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs":
/*!***********************************************************!*\
  !*** ../packages/react/dist/elastic-collisions-react.mjs ***!
  \***********************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionBox: function() { return /* binding */ CollisionBox; },\n/* harmony export */   \"default\": function() { return /* binding */ ReactElasticCollision; },\n/* harmony export */   useElasticCollision: function() { return /* binding */ useElasticCollision; }\n/* harmony export */ });\n/* harmony import */ var _darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @darkroom.engineering/hamo */ \"(app-pages-browser)/../node_modules/.pnpm/@darkroom.engineering+hamo@0.6.45_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@darkroom.engineering/hamo/dist/hamo.modern.mjs\");\n/* harmony import */ var _use_gesture_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/react */ \"(app-pages-browser)/../node_modules/.pnpm/@use-gesture+react@10.3.1_react@18.3.1/node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.4_@babel+core@7.24.9_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.77.8/node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\n\n\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(t) {\n        for(var i = 1; i < arguments.length; i++){\n            var s = arguments[i];\n            for(var e in s)({}).hasOwnProperty.call(s, e) && (t[e] = s[e]);\n        }\n        return t;\n    }, _extends.apply(null, arguments);\n}\nclass ElasticCollision {\n    initialConditions(t, i) {\n        let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>{};\n        this.container = i, this.dimensions = t.map((t)=>{\n            if (!t) return [\n                0,\n                0\n            ];\n            const { rect: i } = t;\n            return [\n                i.width / 2,\n                i.height / 2\n            ];\n        }), s(this), this.positions.forEach((i, s)=>{\n            var _t_s;\n            this.hash[s] = Math.floor(this.gridSize * (i[0] / this.container.width)) + Math.floor(this.gridSize * (i[1] / this.container.height)) * this.gridSize, this.setPosition((_t_s = t[s]) === null || _t_s === void 0 ? void 0 : _t_s.element, {\n                x: i[0],\n                y: i[1]\n            });\n        });\n    }\n    polarCoordinates(t) {\n        return {\n            speed: Math.sqrt(t[0] * t[0] + t[1] * t[1]),\n            angle: Math.atan2(t[1], t[0])\n        };\n    }\n    cartesianCoordinates(t, i) {\n        return [\n            t * Math.cos(i),\n            t * Math.sin(i)\n        ];\n    }\n    hasBounced(t) {\n        return this.bounced[t] += 1;\n    }\n    setPosition(t, param) {\n        let { x: i = 0, y: s = 0, z: e = 0 } = param;\n        t && (t.style.cssText = \"transform: translate3d(\".concat(i, \"px, \").concat(s, \"px, \").concat(e, \"px);\"));\n    }\n    rigidBorders(t) {\n        if (\"rigid\" === this.calculateBorders) for(let i = 0; i < t.length; i++){\n            const t = this.dimensions[i];\n            let s = this.velocities[i], e = this.positions[i];\n            e[1] < t[1] + this.container.height * this.containerOffsets.top && (this.hasBounced(i), this.velocities[i][1] = -s[1], this.positions[i][1] = t[1] + this.container.height * this.containerOffsets.top), e[0] < t[0] + this.container.width * this.containerOffsets.left && (this.hasBounced(i), this.velocities[i][0] = -s[0], this.positions[i][0] = t[0] + this.container.width * this.containerOffsets.left), e[1] > this.container.height * (this.containerOffsets.bottom + 1) - t[1] && (this.hasBounced(i), this.velocities[i][1] = -s[1], this.positions[i][1] = this.container.height * (this.containerOffsets.bottom + 1) - t[1]), e[0] > this.container.width * (this.containerOffsets.right + 1) - t[0] && (this.hasBounced(i), this.velocities[i][0] = -s[0], this.positions[i][0] = this.container.width * (this.containerOffsets.right + 1) - t[0]);\n        }\n    }\n    periodicBorders(t) {\n        if (\"periodic\" === this.calculateBorders) for(let i = 0; i < t.length; i++){\n            const t = this.dimensions[i];\n            let s = this.positions[i], e = this.velocities[i].map((t)=>Math.sign(t));\n            -1 === e[1] && s[1] < t[1] + this.container.height * this.containerOffsets.top && (this.positions[i][1] = t[1] + this.container.height * this.containerOffsets.bottom), 1 === e[1] && s[1] > this.container.height * this.containerOffsets.bottom - t[1] && (this.positions[i][1] = this.container.height * this.containerOffsets.top - t[1]), -1 === e[0] && s[0] < t[0] + this.container.width * this.containerOffsets.left && (this.positions[i][0] = t[0] + this.container.width * this.containerOffsets.right), 1 === e[0] && s[0] > this.container.width * this.containerOffsets.right - t[0] && (this.positions[i][0] = this.container.width * this.containerOffsets.left - t[0]);\n        }\n    }\n    isNeighboor(t, i) {\n        const s = this.hash[i];\n        let e = this.hash[t], o = !1;\n        for(let t = -1; t < 2; t++)for(let i = -1; i < 2; i++){\n            let n = e + this.gridSize * t + i;\n            if (!(n < 0 || n > this.gridSize * this.gridSize) && n === s) {\n                o = !0;\n                break;\n            }\n        }\n        return o;\n    }\n    axisAlignedBoundaryBoxes(t, i) {\n        const s = this.dimensions[t], e = this.positions[t], o = this.dimensions[i], n = this.positions[i];\n        return e.map((t, i)=>Math.abs(t - n[i]) < s[i] + o[i]).every((t)=>t);\n    }\n    calculateSuperposition(t, i) {\n        let s = [\n            0,\n            0\n        ];\n        const e = this.positions[t], o = this.dimensions[t], n = this.positions[i], r = this.dimensions[i], h = e.map((t, i)=>o[i] + r[i] - Math.abs(t - n[i]));\n        return h[0] < h[1] ? e[0] < n[0] ? s[0] = h[0] : s[0] = -h[0] : e[1] < n[1] ? s[1] = h[1] : s[1] = -h[1], s.map((t)=>t + Math.random() * this.collisionRandomness);\n    }\n    collisions(t) {\n        if (this.calculatecCollisions) {\n            this.collisionsList = [];\n            for(let i = 0; i < t.length; i++){\n                let t = this.velocities[i];\n                this.hash.forEach((s, e)=>{\n                    if (e === i) return;\n                    let o = this.velocities[e];\n                    if (this.collisionsList.some((param)=>{\n                        let { loop: t, inHash: s } = param;\n                        return t === e && s === i;\n                    })) return;\n                    if (!this.isNeighboor(i, e)) return;\n                    if (!this.axisAlignedBoundaryBoxes(i, e)) return;\n                    this.collisionsList.push({\n                        loop: i,\n                        inHash: e\n                    });\n                    const n = .5 * (t.reduce((t, i)=>t + i * i, 0) + o.reduce((t, i)=>t + i * i, 0)), r = this.calculateSuperposition(i, e);\n                    let h = t.map((t, i)=>t + r[i]), a = o.map((t, i)=>t - r[i]);\n                    const c = .5 * (h.reduce((t, i)=>t + i * i, 0) + a.reduce((t, i)=>t + i * i, 0));\n                    if (0 !== c) {\n                        const t = Math.sqrt(n / c);\n                        h = h.map((i)=>i * t), a = a.map((i)=>i * t);\n                    }\n                    this.velocities[i] = a, this.velocities[e] = h;\n                });\n            }\n        }\n    }\n    update(t, i) {\n        this.rigidBorders(t), this.periodicBorders(t), this.collisions(t), i(this), this.positions.forEach((t, i)=>{\n            this.hash[i] = Math.floor(this.gridSize * t[0] / this.container.width) + Math.floor(this.gridSize * t[1] / this.container.height) * this.gridSize;\n        });\n    }\n    constructor({ gridSize: t = 4, containerOffsets: i = {\n        top: 0,\n        bottom: 1,\n        left: 0,\n        right: 1\n    }, collisions: s = !0, borders: e = \"rigid\", collisionRandomness: o = 0 } = {}){\n        this.calculatecCollisions = s, this.calculateBorders = e, this.collisionRandomness = o, this.gridSize = t, this.containerOffsets = i, this.positions = [], this.velocities = [], this.dimensions = [], this.bounced = [], this.hash = [], this.container = {}, this.collisionsList = [];\n    }\n}\nconst l = {\n    random: function randominitialConditions(param) {\n        let { boxes: t, positions: i, velocities: s, container: e } = param;\n        t.forEach((t, o)=>{\n            i[o] = [\n                Math.random() * e.width,\n                Math.random() * e.height\n            ], s[o] = [\n                .5 * (Math.random() - .5),\n                .5 * (Math.random() - .5)\n            ];\n        });\n    }\n};\nconst d = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useElasticCollision() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(d);\n}\nfunction ReactElasticCollision(param) {\n    let { children: s, className: o, config: c = {\n        gridSize: 8,\n        collisions: !1,\n        borders: \"rigid\",\n        containerOffsets: {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        }\n    }, presets: f = {\n        initialConditions: null,\n        update: null\n    }, initialConditions: u = ()=>{}, update: p = ()=>{} } = param;\n    const m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map), [g, v] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), [x] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new ElasticCollision(c)), S = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((t, i)=>{\n        m.current.set(t, i);\n    }, []), B = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((t)=>{\n        m.current.delete(t);\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let t = u;\n        const i = [\n            ...m.current.values()\n        ];\n        if (!function isEmptyArray(t) {\n            return !t || Array.isArray(t) && 0 === t.length;\n        }(i) && !i.some((param)=>{\n            let { rect: t } = param;\n            return !t;\n        })) {\n            if (f.initialConditions && (t = l[f.initialConditions], !t)) throw t = l.random, new Error(\"No setup preset found for \".concat(f.initialConditions, \" defaulting to random\"));\n            x.initialConditions(i, v, (s)=>t({\n                    boxes: i,\n                    ...s\n                }));\n        }\n    }, [\n        x,\n        v,\n        u\n    ]), (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useFrame)((t, i)=>{\n        const s = [\n            ...m.current.values()\n        ];\n        x.update(s, (t)=>{\n            p({\n                boxes: s,\n                ...t,\n                deltaTime: i\n            }), s.forEach((i, s)=>{\n                const e = t.positions[s], o = t.dimensions[s];\n                t === null || t === void 0 ? void 0 : t.setPosition(i === null || i === void 0 ? void 0 : i.element, {\n                    x: e[0] - o[0],\n                    y: e[1]\n                });\n            });\n        });\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: o,\n        ref: g,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(d.Provider, {\n        value: {\n            addBox: S,\n            removeBox: B\n        }\n    }, s));\n}\n_c = ReactElasticCollision;\nfunction CollisionBox(param) {\n    let { className: i, children: o, onDragStop: r = ()=>{}, ...h } = param;\n    _s();\n    const { addBox: c, removeBox: l } = useElasticCollision(), [d, f] = (0,_darkroom_engineering_hamo__WEBPACK_IMPORTED_MODULE_1__.useRect)(), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (u.current) return c(u.current, {\n            element: u.current,\n            rect: f\n        }), ()=>{\n            l(u.current);\n        };\n    }, [\n        f,\n        c,\n        l\n    ]);\n    const p = (0,_use_gesture_react__WEBPACK_IMPORTED_MODULE_2__.useDrag)((param)=>{\n        let { down: t, movement: [i, s] } = param;\n        t && r([\n            i,\n            s\n        ]);\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: (t)=>{\n            u.current = t, d(t);\n        },\n        className: i\n    }, h), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", p(), o));\n}\n_s(CollisionBox, \"6CmlvcLHWPJxczwlJYyGQTZayS0=\", false, function() {\n    return [\n        useElasticCollision,\n        useElasticCollision,\n        useElasticCollision\n    ];\n});\n_c1 = CollisionBox;\n //# sourceMappingURL=elastic-collisions-react.mjs.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ReactElasticCollision\");\n$RefreshReg$(_c1, \"CollisionBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                __webpack_module__.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9wYWNrYWdlcy9yZWFjdC9kaXN0L2VsYXN0aWMtY29sbGlzaW9ucy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BO0lBQWtaQyxhQUFhQyxDQUFBQSxFQUFFQyxDQUFBQSxFQUFJO1lBQUZDLElBQUFBLGlFQUFFO1FBQVFDLElBQUFBLENBQUtDLFNBQUFBLEdBQVVILEdBQUVFLElBQUFBLENBQUtFLFVBQUFBLEdBQVdMLEVBQUVNLEdBQUFBLENBQUtOLENBQUFBO1lBQUksS0FBSUEsR0FBRSxPQUFNO2dCQUFDO2dCQUFFO2FBQUE7WUFBRyxRQUFNTyxNQUFLTixDQUFBQSxFQUFBQSxHQUFHRDtZQUFFLE9BQU07Z0JBQUNDLEVBQUVPLEtBQUFBLEdBQU07Z0JBQUVQLEVBQUVRLE1BQUFBLEdBQU87YUFBRztRQUFBLElBQUdQLEVBQUVDLElBQUFBLEdBQU1BLElBQUFBLENBQUtPLFNBQUFBLENBQVVDLE9BQUFBLENBQVMsQ0FBQ1YsR0FBRUM7Z0JBQThKRjtZQUF6SkcsSUFBQUEsQ0FBS1MsSUFBQUEsQ0FBS1YsRUFBQUEsR0FBR1csS0FBS0MsS0FBQUEsQ0FBTVgsSUFBQUEsQ0FBS1ksUUFBQUEsR0FBVWQsQ0FBQUEsQ0FBQUEsQ0FBRSxLQUFHRSxJQUFBQSxDQUFLQyxTQUFBQSxDQUFVSSxLQUFBQSxLQUFRSyxLQUFLQyxLQUFBQSxDQUFNWCxJQUFBQSxDQUFLWSxRQUFBQSxHQUFVZCxDQUFBQSxDQUFBQSxDQUFFLEtBQUdFLElBQUFBLENBQUtDLFNBQUFBLENBQVVLLE1BQUFBLEtBQVNOLElBQUFBLENBQUtZLFFBQUFBLEVBQVNaLElBQUFBLENBQUthLFdBQUFBLEVBQVloQixPQUFBQSxDQUFBQSxDQUFFRSxFQUFBQSxjQUFGRiwyQkFBQUEsS0FBTWlCLE9BQUFBLEVBQVE7Z0JBQUNDLEdBQUVqQixDQUFBQSxDQUFFO2dCQUFHa0IsR0FBRWxCLENBQUFBLENBQUU7WUFB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RUFBVztZQUFDTztZQUFJQztTQUFBQTtJQUNsQjtJQUdGLHFCQUNFZixnREFBQUMsQ0FBQSxPQUFBZSxTQUFBO1FBQ0VkLEtBQU1lLENBQUFBO1lBQ0pSLEVBQVcxQixPQUFBQSxHQUFVa0MsR0FDckJULEVBQVdTO1FBQUs7UUFFbEJoRCxXQUFXQTtJQUFBQSxHQUNQcUMsa0JBRUpOLGdEQUFBQyxDQUFBLE9BQVNTLEtBQVMxQztBQUd4QjtHQXpDU3FDOztRQU11QnhDO1FBQUFBO1FBQUFBOzs7TUFOdkJ3QztBQXlDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vZW5naW5lL2Rpc3QvZWxhc3RpYy1jb2xsaXNpb25zLm1qcz80MDkwIiwid2VicGFjazovL19OX0UvLi4vc3JjL3ByZXNldHMuanM/YWMwMiIsIndlYnBhY2s6Ly9fTl9FLy4uL3NyYy9pbmRleC5qcz81YTYwIiwid2VicGFjazovL19OX0UvLi4vc3JjL3V0aWxzLmpzP2FjZTAiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRWxhc3RpY0NvbGxpc2lvbntjb25zdHJ1Y3Rvcih7Z3JpZFNpemU6aT00LGNvbnRhaW5lck9mZnNldHM6dD17dG9wOjAsYm90dG9tOjEsbGVmdDowLHJpZ2h0OjF9LGNvbGxpc2lvbnM6cz0hMCxib3JkZXJzOm89XCJyaWdpZFwiLGNvbGxpc2lvblJhbmRvbW5lc3M6ZT0wfT17fSl7dGhpcy5jYWxjdWxhdGVjQ29sbGlzaW9ucz1zLHRoaXMuY2FsY3VsYXRlQm9yZGVycz1vLHRoaXMuY29sbGlzaW9uUmFuZG9tbmVzcz1lLHRoaXMuZ3JpZFNpemU9aSx0aGlzLmNvbnRhaW5lck9mZnNldHM9dCx0aGlzLnBvc2l0aW9ucz1bXSx0aGlzLnZlbG9jaXRpZXM9W10sdGhpcy5kaW1lbnNpb25zPVtdLHRoaXMuYm91bmNlZD1bXSx0aGlzLmhhc2g9W10sdGhpcy5jb250YWluZXI9e30sdGhpcy5jb2xsaXNpb25zTGlzdD1bXX1pbml0aWFsU2V0dXAoaSx0LHM9KCk9Pnt9KXt0aGlzLmNvbnRhaW5lcj10LHRoaXMuZGltZW5zaW9ucz1pLm1hcCgoaT0+e2lmKCFpKXJldHVyblswLDBdO2NvbnN0e3JlY3Q6dH09aTtyZXR1cm5bdC53aWR0aC8yLHQuaGVpZ2h0LzJdfSkpLHModGhpcyksdGhpcy5wb3NpdGlvbnMuZm9yRWFjaCgoKHQscyk9Pnt0aGlzLmhhc2hbc109TWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKih0WzBdL3RoaXMuY29udGFpbmVyLndpZHRoKSkrTWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKih0WzFdL3RoaXMuY29udGFpbmVyLmhlaWdodCkpKnRoaXMuZ3JpZFNpemUsdGhpcy5zZXRQb3NpdGlvbihpW3NdPy5lbGVtZW50LHt4OnRbMF0seTp0WzFdfSl9KSl9cG9sYXJDb29yZGluYXRlcyhpKXtyZXR1cm57c3BlZWQ6TWF0aC5zcXJ0KGlbMF0qaVswXStpWzFdKmlbMV0pLGFuZ2xlOk1hdGguYXRhbjIoaVsxXSxpWzBdKX19Y2FydGVzaWFuQ29vcmRpbmF0ZXMoaSx0KXtyZXR1cm5baSpNYXRoLmNvcyh0KSxpKk1hdGguc2luKHQpXX1oYXNCb3VuY2VkKGkpe3JldHVybiB0aGlzLmJvdW5jZWRbaV0rPTF9c2V0UG9zaXRpb24oaSx7eDp0PTAseTpzPTAsejpvPTB9KXtpJiYoaS5zdHlsZS5jc3NUZXh0PWB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCR7dH1weCwgJHtzfXB4LCAke299cHgpO2ApfXJpZ2lkQm9yZGVycyhpKXtpZihcInJpZ2lkXCI9PT10aGlzLmNhbGN1bGF0ZUJvcmRlcnMpZm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5kaW1lbnNpb25zW3RdO2xldCBzPXRoaXMudmVsb2NpdGllc1t0XSxvPXRoaXMucG9zaXRpb25zW3RdO29bMV08aVsxXSt0aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLnRvcCYmKHRoaXMuaGFzQm91bmNlZCh0KSx0aGlzLnZlbG9jaXRpZXNbdF1bMV09LXNbMV0sdGhpcy5wb3NpdGlvbnNbdF1bMV09aVsxXSt0aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLnRvcCksb1swXTxpWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5sZWZ0JiYodGhpcy5oYXNCb3VuY2VkKHQpLHRoaXMudmVsb2NpdGllc1t0XVswXT0tc1swXSx0aGlzLnBvc2l0aW9uc1t0XVswXT1pWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5sZWZ0KSxvWzFdPnRoaXMuY29udGFpbmVyLmhlaWdodCoodGhpcy5jb250YWluZXJPZmZzZXRzLmJvdHRvbSsxKS1pWzFdJiYodGhpcy5oYXNCb3VuY2VkKHQpLHRoaXMudmVsb2NpdGllc1t0XVsxXT0tc1sxXSx0aGlzLnBvc2l0aW9uc1t0XVsxXT10aGlzLmNvbnRhaW5lci5oZWlnaHQqKHRoaXMuY29udGFpbmVyT2Zmc2V0cy5ib3R0b20rMSktaVsxXSksb1swXT50aGlzLmNvbnRhaW5lci53aWR0aCoodGhpcy5jb250YWluZXJPZmZzZXRzLnJpZ2h0KzEpLWlbMF0mJih0aGlzLmhhc0JvdW5jZWQodCksdGhpcy52ZWxvY2l0aWVzW3RdWzBdPS1zWzBdLHRoaXMucG9zaXRpb25zW3RdWzBdPXRoaXMuY29udGFpbmVyLndpZHRoKih0aGlzLmNvbnRhaW5lck9mZnNldHMucmlnaHQrMSktaVswXSl9fXBlcmlvZGljQm9yZGVycyhpKXtpZihcInBlcmlvZGljXCI9PT10aGlzLmNhbGN1bGF0ZUJvcmRlcnMpZm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0IGk9dGhpcy5kaW1lbnNpb25zW3RdO2xldCBzPXRoaXMucG9zaXRpb25zW3RdLG89dGhpcy52ZWxvY2l0aWVzW3RdLm1hcCgoaT0+TWF0aC5zaWduKGkpKSk7LTE9PT1vWzFdJiZzWzFdPGlbMV0rdGhpcy5jb250YWluZXIuaGVpZ2h0KnRoaXMuY29udGFpbmVyT2Zmc2V0cy50b3AmJih0aGlzLnBvc2l0aW9uc1t0XVsxXT1pWzFdK3RoaXMuY29udGFpbmVyLmhlaWdodCp0aGlzLmNvbnRhaW5lck9mZnNldHMuYm90dG9tKSwxPT09b1sxXSYmc1sxXT50aGlzLmNvbnRhaW5lci5oZWlnaHQqdGhpcy5jb250YWluZXJPZmZzZXRzLmJvdHRvbS1pWzFdJiYodGhpcy5wb3NpdGlvbnNbdF1bMV09dGhpcy5jb250YWluZXIuaGVpZ2h0KnRoaXMuY29udGFpbmVyT2Zmc2V0cy50b3AtaVsxXSksLTE9PT1vWzBdJiZzWzBdPGlbMF0rdGhpcy5jb250YWluZXIud2lkdGgqdGhpcy5jb250YWluZXJPZmZzZXRzLmxlZnQmJih0aGlzLnBvc2l0aW9uc1t0XVswXT1pWzBdK3RoaXMuY29udGFpbmVyLndpZHRoKnRoaXMuY29udGFpbmVyT2Zmc2V0cy5yaWdodCksMT09PW9bMF0mJnNbMF0+dGhpcy5jb250YWluZXIud2lkdGgqdGhpcy5jb250YWluZXJPZmZzZXRzLnJpZ2h0LWlbMF0mJih0aGlzLnBvc2l0aW9uc1t0XVswXT10aGlzLmNvbnRhaW5lci53aWR0aCp0aGlzLmNvbnRhaW5lck9mZnNldHMubGVmdC1pWzBdKX19aXNOZWlnaGJvb3IoaSx0KXtjb25zdCBzPXRoaXMuaGFzaFt0XTtsZXQgbz10aGlzLmhhc2hbaV0sZT0hMTtmb3IobGV0IGk9LTE7aTwyO2krKylmb3IobGV0IHQ9LTE7dDwyO3QrKyl7bGV0IGg9byt0aGlzLmdyaWRTaXplKmkrdDtpZighKGg8MHx8aD50aGlzLmdyaWRTaXplKnRoaXMuZ3JpZFNpemUpJiZoPT09cyl7ZT0hMDticmVha319cmV0dXJuIGV9YXhpc0FsaWduZWRCb3VuZGFyeUJveGVzKGksdCl7Y29uc3Qgcz10aGlzLmRpbWVuc2lvbnNbaV0sbz10aGlzLnBvc2l0aW9uc1tpXSxlPXRoaXMuZGltZW5zaW9uc1t0XSxoPXRoaXMucG9zaXRpb25zW3RdO3JldHVybiBvLm1hcCgoKGksdCk9Pk1hdGguYWJzKGktaFt0XSk8c1t0XStlW3RdKSkuZXZlcnkoKGk9PmkpKX1jYWxjdWxhdGVTdXBlcnBvc2l0aW9uKGksdCl7bGV0IHM9WzAsMF07Y29uc3Qgbz10aGlzLnBvc2l0aW9uc1tpXSxlPXRoaXMuZGltZW5zaW9uc1tpXSxoPXRoaXMucG9zaXRpb25zW3RdLG49dGhpcy5kaW1lbnNpb25zW3RdLHI9by5tYXAoKChpLHQpPT5lW3RdK25bdF0tTWF0aC5hYnMoaS1oW3RdKSkpO3JldHVybiByWzBdPHJbMV0/b1swXTxoWzBdP3NbMF09clswXTpzWzBdPS1yWzBdOm9bMV08aFsxXT9zWzFdPXJbMV06c1sxXT0tclsxXSxzLm1hcCgoaT0+aStNYXRoLnJhbmRvbSgpKnRoaXMuY29sbGlzaW9uUmFuZG9tbmVzcykpfWNvbGxpc2lvbnMoaSl7aWYodGhpcy5jYWxjdWxhdGVjQ29sbGlzaW9ucyl7dGhpcy5jb2xsaXNpb25zTGlzdD1bXTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrKyl7bGV0IGk9dGhpcy52ZWxvY2l0aWVzW3RdO3RoaXMuaGFzaC5mb3JFYWNoKCgocyxvKT0+e2lmKG89PT10KXJldHVybjtsZXQgZT10aGlzLnZlbG9jaXRpZXNbb107aWYodGhpcy5jb2xsaXNpb25zTGlzdC5zb21lKCgoe2xvb3A6aSxpbkhhc2g6c30pPT5pPT09byYmcz09PXQpKSlyZXR1cm47aWYoIXRoaXMuaXNOZWlnaGJvb3IodCxvKSlyZXR1cm47aWYoIXRoaXMuYXhpc0FsaWduZWRCb3VuZGFyeUJveGVzKHQsbykpcmV0dXJuO3RoaXMuY29sbGlzaW9uc0xpc3QucHVzaCh7bG9vcDp0LGluSGFzaDpvfSk7Y29uc3QgaD0uNSooaS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkrZS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkpLG49dGhpcy5jYWxjdWxhdGVTdXBlcnBvc2l0aW9uKHQsbyk7bGV0IHI9aS5tYXAoKChpLHQpPT5pK25bdF0pKSxhPWUubWFwKCgoaSx0KT0+aS1uW3RdKSk7Y29uc3QgYz0uNSooci5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkrYS5yZWR1Y2UoKChpLHQpPT5pK3QqdCksMCkpO2lmKDAhPT1jKXtjb25zdCBpPU1hdGguc3FydChoL2MpO3I9ci5tYXAoKHQ9PnQqaSkpLGE9YS5tYXAoKHQ9PnQqaSkpfXRoaXMudmVsb2NpdGllc1t0XT1hLHRoaXMudmVsb2NpdGllc1tvXT1yfSkpfX19dXBkYXRlKGksdCl7dGhpcy5yaWdpZEJvcmRlcnMoaSksdGhpcy5wZXJpb2RpY0JvcmRlcnMoaSksdGhpcy5jb2xsaXNpb25zKGkpLHQodGhpcyksdGhpcy5wb3NpdGlvbnMuZm9yRWFjaCgoKGksdCk9Pnt0aGlzLmhhc2hbdF09TWF0aC5mbG9vcih0aGlzLmdyaWRTaXplKmlbMF0vdGhpcy5jb250YWluZXIud2lkdGgpK01hdGguZmxvb3IodGhpcy5ncmlkU2l6ZSppWzFdL3RoaXMuY29udGFpbmVyLmhlaWdodCkqdGhpcy5ncmlkU2l6ZX0pKX19ZXhwb3J0e0VsYXN0aWNDb2xsaXNpb24gYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGFzdGljLWNvbGxpc2lvbnMubWpzLm1hcFxuIiwiZnVuY3Rpb24gcmFuZG9tSW5pdGlhbFNldHVwKHsgYm94ZXMsIHBvc2l0aW9ucywgdmVsb2NpdGllcywgY29udGFpbmVyIH0pIHtcbiAgYm94ZXMuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICBwb3NpdGlvbnNbaW5kZXhdID0gW1xuICAgICAgTWF0aC5yYW5kb20oKSAqIGNvbnRhaW5lci53aWR0aCxcbiAgICAgIE1hdGgucmFuZG9tKCkgKiBjb250YWluZXIuaGVpZ2h0LFxuICAgIF1cbiAgICB2ZWxvY2l0aWVzW2luZGV4XSA9IFtcbiAgICAgIDAuNSAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSxcbiAgICAgIDAuNSAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSxcbiAgICBdXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBzZXR1cFByZXNldHMgPSB7XG4gIHJhbmRvbTogcmFuZG9tSW5pdGlhbFNldHVwLFxufVxuIiwiaW1wb3J0IHsgdXNlRnJhbWUsIHVzZVJlY3QgfSBmcm9tICdAZGFya3Jvb20uZW5naW5lZXJpbmcvaGFtbydcbmltcG9ydCB7IHVzZURyYWcgfSBmcm9tICdAdXNlLWdlc3R1cmUvcmVhY3QnXG5pbXBvcnQgUmVhY3QsIHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWxhc3RpY0NvbGxpc2lvbiBmcm9tICcuLi8uLi9lbmdpbmUvZGlzdC9lbGFzdGljLWNvbGxpc2lvbnMubWpzJ1xuaW1wb3J0IHsgc2V0dXBQcmVzZXRzIH0gZnJvbSAnLi9wcmVzZXRzJ1xuaW1wb3J0IHsgaXNFbXB0eUFycmF5IH0gZnJvbSAnLi91dGlscydcblxuY29uc3QgRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KVxuXG5mdW5jdGlvbiB1c2VFbGFzdGljQ29sbGlzaW9uKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChFbGFzdGljQ29sbGlzaW9uQ29udGV4dClcbn1cblxuZnVuY3Rpb24gUmVhY3RFbGFzdGljQ29sbGlzaW9uKHtcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZSxcbiAgY29uZmlnID0ge1xuICAgIGdyaWRTaXplOiA4LFxuICAgIGNvbGxpc2lvbnM6IGZhbHNlLFxuICAgIGJvcmRlcnM6ICdyaWdpZCcsXG4gICAgY29udGFpbmVyT2Zmc2V0czoge1xuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH0sXG4gIH0sXG4gIHByZXNldHMgPSB7XG4gICAgaW5pdGlhbFNldHVwOiBudWxsLFxuICAgIHVwZGF0ZTogbnVsbCxcbiAgfSxcbiAgaW5pdGlhbFNldHVwID0gKCkgPT4ge30sXG4gIHVwZGF0ZSA9ICgpID0+IHt9LFxufSkge1xuICBjb25zdCBib3hlc1JlZnMgPSB1c2VSZWYobmV3IE1hcCgpKVxuICBjb25zdCBbc2VjdGlvblJlY3RSZWYsIHNlY3Rpb25SZWN0XSA9IHVzZVJlY3QoKVxuICBjb25zdCBbZWxhc3RpY0NvbGxpc2lvbl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgRWxhc3RpY0NvbGxpc2lvbihjb25maWcpKVxuXG4gIGNvbnN0IGFkZEJveCA9IHVzZUNhbGxiYWNrKChlbGVtZW50LCBzbGlkZSkgPT4ge1xuICAgIGJveGVzUmVmcy5jdXJyZW50LnNldChlbGVtZW50LCBzbGlkZSlcbiAgfSwgW10pXG4gIGNvbnN0IHJlbW92ZUJveCA9IHVzZUNhbGxiYWNrKChlbGVtZW50KSA9PiB7XG4gICAgYm94ZXNSZWZzLmN1cnJlbnQuZGVsZXRlKGVsZW1lbnQpXG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHNlbGVjdGVkU2V0dXAgPSBpbml0aWFsU2V0dXBcbiAgICBjb25zdCBib3hlcyA9IFsuLi5ib3hlc1JlZnMuY3VycmVudC52YWx1ZXMoKV1cblxuICAgIGlmIChpc0VtcHR5QXJyYXkoYm94ZXMpKSByZXR1cm5cblxuICAgIGlmIChib3hlcy5zb21lKCh7IHJlY3QgfSkgPT4gIXJlY3QpKSByZXR1cm5cblxuICAgIGlmIChwcmVzZXRzLmluaXRpYWxTZXR1cCkge1xuICAgICAgc2VsZWN0ZWRTZXR1cCA9IHNldHVwUHJlc2V0c1twcmVzZXRzLmluaXRpYWxTZXR1cF1cbiAgICAgIGlmICghc2VsZWN0ZWRTZXR1cCkge1xuICAgICAgICBzZWxlY3RlZFNldHVwID0gc2V0dXBQcmVzZXRzLnJhbmRvbVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgTm8gc2V0dXAgcHJlc2V0IGZvdW5kIGZvciAke3ByZXNldHMuaW5pdGlhbFNldHVwfSBkZWZhdWx0aW5nIHRvIHJhbmRvbWBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICBlbGFzdGljQ29sbGlzaW9uLmluaXRpYWxTZXR1cChib3hlcywgc2VjdGlvblJlY3QsIChpbnN0YW5jZXMpID0+XG4gICAgICBzZWxlY3RlZFNldHVwKHsgYm94ZXMsIC4uLmluc3RhbmNlcyB9KVxuICAgIClcbiAgfSwgW2VsYXN0aWNDb2xsaXNpb24sIHNlY3Rpb25SZWN0LCBpbml0aWFsU2V0dXBdKVxuXG4gIHVzZUZyYW1lKChfLCBkZWx0YVRpbWUpID0+IHtcbiAgICBjb25zdCBib3hlcyA9IFsuLi5ib3hlc1JlZnMuY3VycmVudC52YWx1ZXMoKV1cblxuICAgIGVsYXN0aWNDb2xsaXNpb24udXBkYXRlKGJveGVzLCAoaW5zdGFuY2UpID0+IHtcbiAgICAgIHVwZGF0ZSh7IGJveGVzLCAuLi5pbnN0YW5jZSwgZGVsdGFUaW1lIH0pXG5cbiAgICAgIGJveGVzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5zdGFuY2UucG9zaXRpb25zW2luZGV4XVxuICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gaW5zdGFuY2UuZGltZW5zaW9uc1tpbmRleF1cblxuICAgICAgICBpbnN0YW5jZT8uc2V0UG9zaXRpb24oZWxlbWVudD8uZWxlbWVudCwge1xuICAgICAgICAgIC8vIHNoaWZ0IGNlbnRlcnMgZWxlbWVudCB0byBjZW50ZXIgb2YgbWFzc1xuICAgICAgICAgIHg6IHBvc2l0aW9uWzBdIC0gZGltZW5zaW9uc1swXSxcbiAgICAgICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgcmVmPXtzZWN0aW9uUmVjdFJlZn1cbiAgICAgIHN0eWxlPXt7IHBvc2l0aW9uOiAncmVsYXRpdmUnLCB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9fVxuICAgID5cbiAgICAgIDxFbGFzdGljQ29sbGlzaW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBhZGRCb3gsIHJlbW92ZUJveCB9fT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9FbGFzdGljQ29sbGlzaW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiBDb2xsaXNpb25Cb3goe1xuICBjbGFzc05hbWUsXG4gIGNoaWxkcmVuLFxuICBvbkRyYWdTdG9wID0gKCkgPT4ge30sXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgYWRkQm94LCByZW1vdmVCb3ggfSA9IHVzZUVsYXN0aWNDb2xsaXNpb24oKVxuICBjb25zdCBbc2V0UmVjdFJlZiwgcmVjdF0gPSB1c2VSZWN0KClcbiAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZigpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICBhZGRCb3goZWxlbWVudFJlZi5jdXJyZW50LCB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRSZWYuY3VycmVudCxcbiAgICAgICAgcmVjdCxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlbW92ZUJveChlbGVtZW50UmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbcmVjdCwgYWRkQm94LCByZW1vdmVCb3hdKVxuXG4gIGNvbnN0IGJpbmQgPSB1c2VEcmFnKCh7IGRvd24sIG1vdmVtZW50OiBbbXgsIG15XSB9KSA9PiB7XG4gICAgaWYgKGRvd24pIHtcbiAgICAgIG9uRHJhZ1N0b3AoW214LCBteV0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXsobm9kZSkgPT4ge1xuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBub2RlXG4gICAgICAgIHNldFJlY3RSZWYobm9kZSlcbiAgICAgIH19XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8ZGl2IHsuLi5iaW5kKCl9PntjaGlsZHJlbn08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdEVsYXN0aWNDb2xsaXNpb25cbmV4cG9ydCB7IENvbGxpc2lvbkJveCwgdXNlRWxhc3RpY0NvbGxpc2lvbiB9XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNFbXB0eUFycmF5KGFycikge1xuICBpZiAoIWFycikgcmV0dXJuIHRydWVcblxuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5sZW5ndGggPT09IDBcbn1cbiJdLCJuYW1lcyI6WyJFbGFzdGljQ29sbGlzaW9uIiwiaW5pdGlhbFNldHVwIiwiaSIsInQiLCJzIiwidGhpcyIsImNvbnRhaW5lciIsImRpbWVuc2lvbnMiLCJtYXAiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbnMiLCJmb3JFYWNoIiwiaGFzaCIsIk1hdGgiLCJmbG9vciIsImdyaWRTaXplIiwic2V0UG9zaXRpb24iLCJlbGVtZW50IiwieCIsInkiLCJwb2xhckNvb3JkaW5hdGVzIiwic3BlZWQiLCJzcXJ0IiwiYW5nbGUiLCJhdGFuMiIsImNhcnRlc2lhbkNvb3JkaW5hdGVzIiwiY29zIiwic2luIiwiaGFzQm91bmNlZCIsImJvdW5jZWQiLCJ6IiwibyIsInN0eWxlIiwiY3NzVGV4dCIsInJpZ2lkQm9yZGVycyIsImNhbGN1bGF0ZUJvcmRlcnMiLCJsZW5ndGgiLCJ2ZWxvY2l0aWVzIiwiY29udGFpbmVyT2Zmc2V0cyIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInBlcmlvZGljQm9yZGVycyIsInNpZ24iLCJpc05laWdoYm9vciIsImUiLCJoIiwiYXhpc0FsaWduZWRCb3VuZGFyeUJveGVzIiwiYWJzIiwiZXZlcnkiLCJjYWxjdWxhdGVTdXBlcnBvc2l0aW9uIiwibiIsInIiLCJyYW5kb20iLCJjb2xsaXNpb25SYW5kb21uZXNzIiwiY29sbGlzaW9ucyIsImNhbGN1bGF0ZWNDb2xsaXNpb25zIiwiY29sbGlzaW9uc0xpc3QiLCJzb21lIiwibG9vcCIsImluSGFzaCIsInB1c2giLCJyZWR1Y2UiLCJhIiwiYyIsInVwZGF0ZSIsImNvbnN0cnVjdG9yIiwiYm9yZGVycyIsInNldHVwUHJlc2V0cyIsInJhbmRvbUluaXRpYWxTZXR1cCIsImJveGVzIiwiXyIsImluZGV4IiwiRWxhc3RpY0NvbGxpc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlRWxhc3RpY0NvbGxpc2lvbiIsInVzZUNvbnRleHQiLCJSZWFjdEVsYXN0aWNDb2xsaXNpb24iLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImNvbmZpZyIsInByZXNldHMiLCJib3hlc1JlZnMiLCJ1c2VSZWYiLCJNYXAiLCJzZWN0aW9uUmVjdFJlZiIsInNlY3Rpb25SZWN0IiwidXNlUmVjdCIsImVsYXN0aWNDb2xsaXNpb24iLCJ1c2VTdGF0ZSIsImFkZEJveCIsInVzZUNhbGxiYWNrIiwic2xpZGUiLCJjdXJyZW50Iiwic2V0IiwicmVtb3ZlQm94IiwiZGVsZXRlIiwidXNlRWZmZWN0Iiwic2VsZWN0ZWRTZXR1cCIsInZhbHVlcyIsImlzRW1wdHlBcnJheSIsImFyciIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiaW5zdGFuY2VzIiwidXNlRnJhbWUiLCJkZWx0YVRpbWUiLCJpbnN0YW5jZSIsInBvc2l0aW9uIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIkNvbGxpc2lvbkJveCIsInByb3BzIiwib25EcmFnU3RvcCIsInNldFJlY3RSZWYiLCJlbGVtZW50UmVmIiwiYmluZCIsInVzZURyYWciLCJkb3duIiwibW92ZW1lbnQiLCJteCIsIm15IiwiX2V4dGVuZHMiLCJub2RlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../packages/react/dist/elastic-collisions-react.mjs\n"));

/***/ })

});